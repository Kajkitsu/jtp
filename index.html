<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Języki i Techniki Programowania</title>

	<meta name="description" content="JTP LAB">
	<meta name="author" content="Norbert Waszkowiak">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section data-background-gradient="linear-gradient(45deg, #333, #1f7520)">
				<h2>Języki i Techniki Programowania</h2>
				<br slyle="height: 600px;" />
				<p style="text-align: left;">ppor. mgr inż. Norbert Waszkowiak</p>
				<div class="fragment" style="text-align: left;">
					<small>nr tel.: 261 839 060</small>
					<br />
					<small>e-mail: norbert.waszkowiak@wat.edu.pl</small>
					<br />
					<small>pomieszczenie: bud. 100 pok. 254B</small>
					<br />
					<small>konsultacje online i stacjanarnie: po wcześniejszym umówieniu</small>
				</div>
			</section>
			<section data-background-image="https://kajkitsu.github.io/jtp/assets/fire.jpg"
				data-background-opacity="0.5">
				<h2>Zasady oceniania</h2>
				<section>
					<small>
						<ol>
							<li>Ostateczna ocena z laboratoriów będzie wynikiem egzaminu z cześci laboratoryjnej.
								Za aktywność na laboratoriach i realizacje zadań student może otrzymać maksymalnie 20
								punktów, które są wliczone do
								puli punktów z egzaminu.
							</li>
							<li>Obecność na wszystkich zajęciach jest obowiązkowa. Zaległości można usunąć uczestnicząc
								w
								zajęciach z inną grupą po wcześniejszym poinformowaniu prowadzącego. W przypadku, gdy
								zajęcia z pozostałymi grupami już się odbyły, można odrobić zajęcia na konsultacjach.
								Dopuszczalna liczba nieobecności: 1.</li>
							<li>Rozwiązania zadań z zajęć należy umiescić na platoformie MS Teams. Czas na wykonanie
								zadania
								to tydzień liczony od 23:59 dnia, w którym zostały zrealizowane zajęcia. Jeżeli
								termin
								oddania zadania przypadnie po rozpoczęciu sesji
								egzaminacyjnej, wtedy za termin oddania zadania przyjmuje się 24h przed rozpoczęciem
								sesji
								egzaminacyjnej.</li>
						</ol>
					</small>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(45deg, #c03090, #10a080)">
				<section>
					<h2>Lab 1-2</h2>
					<h3>Stos</h3>
				</section>
				<section>
					<h3>IDE</h3>
					<img src="assets/IntelliJ_IDEA_Icon.svg" style="height: 300px;" />
					<br />

					<a href="https://www.jetbrains.com/help/idea/installation-guide.html#silent">
						Instrukcja instalacji IntelliJ IDEA
					</a>
				</section>

				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1 cz.1 👨‍💻</h3>
					<small style="text-align: left; margin-left: 20px;">
						Wykonanie programu wymaga użycia stosu, na którym zapisywane są zmienne oraz ich wartości, tj.
						wartości prymitywne i odnośniki do obiektów - same obiekty są na tzw. składzie. W tym zadaniu
						zapisujemy stany stosu jako ciąg list par odpowiadający metodom na stosie i zmiennym
						zadeklarowanym
						i modyfikowanym w czasie ich wykonania. Lista par odpowiada metodzie na stosie, jest zapisana w
						nawiasie kwadratowym, a każda para składa się z nazwy zmiennej oraz jej wartości.
						<br />
						Np. <em>[…, (x, 7),(y, true)]main</em> to stan, w którym podczas wykonania metody <em>main</em>
						wartości zmiennych <em>x</em> i <em>y</em> są
						odpowiednio równe 7 i true.
						<br />
						Przeanalizuj następującą klasę i podaj stany stosu po wykonaniu linii 3,
						4, 5, 6, 7, 8 i 10.
					</small>

					<pre style="font-size: 14px" data-id="code-animation">
						<code class="hljs java" data-trim data-line-numbers><script type="text/template">
							public class State {
								public static void main(String[] args) {
									int m = 2;
									double d = 2.0;
									d = m * d;
									int n = 15 + (int) d; {
										int k = 8;
										d = d + k;
									}
									d = n / 4;
									System.out.println(d);
								}
							}
						</script>
						</code>
					</pre>
				</section>

				<section>
					<h3>Debugger</h3>
					<small style="text-align: left; margin: 20px;">(zwany również odpluskwiaczem) - narzędzie
						wbudowane w IDE umożliwiające śledzenie stosu i
						sterty (składu) w wybranych liniach kodu poprzez zatrzymywanie działania programu w danej
						linii.</small>
					<small style="text-align: left; margin: 20px;" class="fragment">Program działający w trybie
						debuggowania będzie wykonywał kolejne linijki kodu do momentu, w
						którym nie trafi na „<b>breakpoint</b>”, czyli linię kodu zaznaczoną przez programistę. Po
						zatrzymaniu
						się programu w wybranej linii, IDE wyświetli aktualny stos zawierający zmienne aplikacji.
						Użytkownik może zwolnić breakpoint, po czym program będzie wykonywany do napotkania kolejnego
						breakpoint'a. </small>
					<small style="text-align: left; margin: 20px;" class="fragment">W środowisku <b>Intellij
							IDEA</b>, aby wybrać linijkę kodu, w których program ma się zatrzymać
						(breakpoint), należy kliknąć po prawej stronie od numeru linii. Linia zapali się na czerwono
						oraz
						pojawi się czerwony okrąg.</small>
				</section>
				<section>
					<h3>Debugger</h3>
					<img src="assets/debugger1.png">
				</section>
				<section>
					<h3>Debugger</h3>
					<img src="assets/debugger2.png">
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1 cz.2 👨‍💻</h3>
					<small style="text-align: left; margin-left: 20px;">
						Podaj stany stosu wywołań i składu, gdy zostaną osiągnięte miejsca (1), (2) oraz (a) i (b).
						<br />
						Użyj debuggera(odpluskwiacza) do sprawdzenia otrzymanych wyników.
						<br />
						Uwaga: proszę pamiętać o parametrze <em>args</em> metody <em>main</em>.
						<br />
						Stos trzeba odpowiednio rozrysować, żeby było widać piętra odpowiadające metodom.
					</small>

					<pre style="font-size: 14px" data-id="code-animation">
						<code class="hljs java" data-trim data-line-numbers><script type="text/template">
							public class ValuePassing {
								public static int changei(int i) {
									int[] a = {i}; /* (a) */
									++i; /* (b) */
									return (i + a[0]);
								}
							
								public static void main(String[] args) {
									int i = 2; /* (1) */
									System.out.println("Przed wykonaniem i ma wartość" + i);
									int return_i = 0;
									return_i = changei(i); /* (2) */
									System.out.println("Changei daje w wyniku " + return_i);
									System.out.println("Wartosc i po wynosi " + i);
								}
							}
						</script>
						</code>
					</pre>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2 👨‍💻</h3>
					<small style="text-align: left; margin-left: 20px;">
						Zaimplementuj klasy <em>Point</em> i <em>Line</em> odpowiadające odpowiednio punktom i liniom w
						przestrzeni
						dwuwymiarowej z odpowiednimi konstruktorami. Klasy te mają zawierać metodę <em>move</em>
						pozwalającą na
						przesuwanie punktów i linii o wektor oraz metodę <em>flip</em> pozwalającą na przerzucanie
						symetryczne
						względem początku układu współrzędnych. Należy napisać testy metod i konstruktorów. Ile
						parametrów powinna mieć metoda <em>move</em>?
						<br />

						Wskazówka: w celu testowania należy zaimplementować odpowiednio metodę <em>toString()</em>
						zwracającą dla
						danego obiektu reprezentujący go string.</small>
				</section>
				<section>
					<h3>Testy jednostkowe</h3>
					<small style="text-align: left; margin: 20px;">
						Na potrzeby przeprowadzania testów jednostkowych w języku Java przygotowano narzędzia
						umożliwiające szybkie i sprawne pisanie testów jednostkowych nazwane Junit. Jest to biblioteka,
						która przy wykorzystaniu <b>anotacji</b> umożliwia definiowanie testów oraz przygotowanie
						obiektów do
						ich wykonania.
					</small>
					<small class="fragment" style="text-align: left; margin: 20px;">
						<b>Anotacja</b> - to część gramatyki języka, reprezentującąca konkretną logikę, którą w czasie
						budowania
						projektu wykonuje kompilator. Anotacje w Javie wstawia się zazwyczaj przed deklaracją
						klas, metod i atrybutów. W przykładzie widocznym po prawej stronie wykorzystywana jest anotacja
						<em>@Before</em> oraz <em>@Test</em>. Metoda poprzedzona anotacją <em>@Before</em> w klasie, w
						której się znajduje, zostanie wykonana przed wywołaniem testów. Anotacja <em>@Test</em>
						poprzedzająca metodę reprezentuje pojedynczy test jednostkowy.
					</small>
					<small class="fragment" style="text-align: left; margin: 20px;">
						Wynik testu będzie pozytywny, jeśli dla wyniku statycznej metody <em>assertEquals</em> wartości
						obu
						parametrów będą równe. W klasie <em>Assert</em> istnieją również inne metody umożliwiające
						przeprowadzanie testów, np. <em>assertTrue</em>, <em>assertNotNull</em> itp..
					</small>
					<small class="fragment" style="text-align: left; margin: 20px;">
						<b>Intellij IDEA</b> umożliwia wywoływanie pojedynczych testów lub wszystkich testów w klasie
						poprzez
						wciśnięcie odpowiednio zielonego przycisku przy numerze linii przy deklaracjach metod i przy
						deklaracji klasy.
					</small>
				</section>
				<section>
					<h3>JUnit</h3>
					<pre style="font-size: 16px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers="1-26|8|10-13|15-19|21-25">
						import static org.junit.Assert.assertEquals;

						import org.junit.Before;
						import org.junit.Test;
						
						public class CalculatorTest {
						
							private Calculator calculator;
						
							@Before
							public void init() {
								calculator = new Calculator();
							}
						
							@Test
							public void testIfAddProperly() {
								int result = calculator.add(4, 6);
								assertEquals(10, result);
							}
						
							@Test
							public void testIfMultiplyProperly() {
								int result = calculator.multiply(5, 5);
								assertEquals(25, result);
							}
						}
						
					</code></pre>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(20deg, #650000, #29448b)" data-auto-animate
				data-auto-animate-easing="cubic-bezier(0.770, 0.100, 0.175, 0.900)">
				<section>
					<h2>Lab 3-4</h2>
					<h3>Kolekcje</h3>
				</section>
				<section data-auto-animate data-auto-animate-easing="cubic-bezier(0.770, 0.100, 0.175, 0.900)">
					<div class="r-hstack justify-center">
						<div class="r-vstack" style="background: rgba(0, 0, 0, 0.336);">
							<div data-id="iterable" data-auto-animate-delay="0" class="fragment"
								style="background: rgb(80, 17, 54); ; width: 250px; height: 100px; margin: 10px;">
								<p style="font-size: 30px;" class="justify-center">java.lang.Iterable</p>
							</div>
							<div data-id="collection" data-auto-animate-delay="0" class="fragment"
								style="background: rgb(68, 31, 117); width: 300px; height: 100px; margin: 10px;">
								<p style="font-size: 30px;" class="justify-center">java.util.Collection</p>
							</div>
							<div class="r-hstack">
								<div data-id="list" data-auto-animate-delay="0" class="fragment"
									style="background: rgb(59, 57, 175); width: 160px; height: 100px; margin: 10px;">
									<p style="font-size: 25px;" class="justify-center">java.util.List</p>
								</div>
								<div data-id="set" data-auto-animate-delay="0.1" class="fragment"
									style="background: rgb(59, 57, 175); width: 160px; height: 100px; margin: 10px;">
									<p style="font-size: 25px;" class="justify-center">java.util.Set</p>
								</div>
								<div data-id="queue" data-auto-animate-delay="0.2" class="fragment"
									style="background: rgb(59, 57, 175); width: 160px; height: 100px; margin: 10px;">
									<p style="font-size: 25px;" class="justify-center">java.util.Queue</p>
								</div>
							</div>
						</div>
						<div data-id="map" data-auto-animate-delay="0.2" class="fragment"
							style="background: rgb(59, 57, 175); width: 160px; height: 100px; margin: 10px; margin-top: 250px;">
							<p style="font-size: 25px;" class="justify-center">java.util.Map</p>
						</div>
					</div>
				</section>
				<section>
					<h3>Typ generyczny</h3>
					<small style="margin-bottom: 10px;">Typ generyczny w Javie umożliwia tworzenie klas, interfejsów i
						metod, które są parametryzowane typem. Oznacza to, że możemy utworzyć klasę lub metodę, która
						będzie działać na różnych typach, a typ będzie określony w momencie tworzenia obiektu klasy lub
						wywoływania metody.</small>
					<small style="margin-bottom: 10px;">Typ generyczny definiuje się za pomocą parametru typu, który
						jest umieszczany w nawiasach trójkątnych &lt&gt. Parametr typu może być dowolnym typem, w tym
						klasą, interfejsem. Parametry typu pozwalają na tworzenie kodu, który jest bardziej ogólny i
						elastyczny, ponieważ typy argumentów mogą być różne dla różnych wywołań klasy lub
						metody.</small>
					<small style="margin-bottom: 10px;">Użycie typów generycznych pozwala na uniknięcie rzutowania typów
						i poprawia bezpieczeństwo typów, ponieważ typy argumentów są sprawdzane w czasie kompilacji. Typ
						generyczny może być używany nie tylko w klasach, ale także w interfejsach i metodach.</small>
					<small style="margin-bottom: 10px;">Przykładem klasy generycznej w Javie jest ArrayList&ltT&gt,
						gdzie T oznacza typ elementów przechowywanych w liście. W momencie tworzenia obiektu ArrayList
						możemy określić typ elementów, na przykład ArrayList&ltString&gt lub
						ArrayList&ltInteger&gt.</small>
				</section>
				<section>
					<h3>Typ generyczny</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
						public class Box<T> {
							private T content;
						
							public Box(T content) {
								this.content = content;
							}
						
							public T getContent() {
								return content;
							}
						
							public void setContent(T content) {
								this.content = content;
							}
						}
						</script></code></pre>

					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
							Box<Integer> intBox = new Box<>(42);
							int intValue = intBox.getContent();
							
							Box<String> stringBox = new Box<>("Hello");
							String stringValue = stringBox.getContent();
						</script></code></pre>

				</section>
				<section>
					<h3>Collection&ltE&gt</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
// dodaje nowy element do kolekcji
boolean add(E element) 

// dodaje do kolekcji wszystkie elementy z innej kolekcji
boolean addAll(Collection<? extends E> c) 

// usuwa wszystkie elementy z kolekcji
void clear() 

// sprawdza, czy kolekcja zawiera podany element
boolean contains(Object o) 

// sprawdza, czy kolekcja zawiera wszystkie elementy z innej kolekcji
boolean containsAll(Collection<?> c) 

// sprawdza, czy kolekcja jest pusta
boolean isEmpty() 

// zwraca iterator umożliwiający iterowanie po elementach kolekcji
Iterator<E> iterator() 

// usuwa podany element z kolekcji
boolean remove(Object o) 

// usuwa z kolekcji wszystkie elementy, które znajdują się w innej kolekcji
boolean removeAll(Collection<?> c) 

// pozostawia w kolekcji tylko te elementy, które znajdują się w innej kolekcji
boolean retainAll(Collection<?> c) 

// zwraca liczbę elementów w kolekcji
int size() 
					</script></code></pre>
				</section>
				<section>
					<h3>List&ltE&gt</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
// dodaje nowy element na wskazanej pozycji
void add(int index, E element)

// zwraca element o wskazanym indeksie
E get(int index)

// ustawia nową wartość dla elementu o wskazanym indeksie
E set(int index, E element)

// usuwa element o wskazanym indeksie z listy
E remove(int index)

// zwraca indeks pierwszego wystąpienia danego obiektu na liście
int indexOf(Object o)

// zwraca indeks ostatniego wystąpienia danego obiektu na liście
int lastIndexOf(Object o)

// zwraca widok listy zawierający elementy od podanego indeksu do
// końcowego indeksu (bez niego)
List<E> subList(int fromIndex, int toIndex)
</script></code></pre>
				</section>
				<section>
					<h3>ArrayList&ltE&gt</h3>
					<small>
						<ul>
							<li>Jest to tablica dynamiczna, która może zwiększać swój rozmiar wraz ze wzrostem ilości
								elementów.
							</li>
							<li>
								W ArrayListach dostęp do elementów jest szybszy niż w LinkedListach, ponieważ elementy
								są przechowywane w pamięci w
								sposób ciągły, co pozwala na prostsze operacje odczytu i zapisu.
							</li>
							<li>
								W ArrayListach usuwanie elementów z początku lub środka listy może być kosztowne
								czasowo, ponieważ wymaga przesunięcia
								wszystkich elementów za usuwanym.
							</li>
							<li>
								Dostęp do elementów w ArrayListach jest O(1), a wyszukiwanie O(n).</li>
						</ul>
					</small>
				</section>
				<section>
					<h3>LinkedList&ltE&gt</h3>
					<small>
						<ul>
							<li>Jest to lista dwukierunkowa, w której każdy element przechowuje referencję do swojego
								poprzednika i następnika.</li>
							<li>W LinkedListach dodawanie i usuwanie elementów z początku i środka listy jest szybsze
								niż w ArrayListach, ponieważ nie
								wymaga przesuwania innych elementów.</li>
							<li>W LinkedListach dostęp do elementów jest wolniejszy niż w ArrayListach, ponieważ
								elementy nie są przechowywane w pamięci
								w sposób ciągły, co wymaga dodatkowych operacji przeglądania listy w celu znalezienia
								danego elementu.</li>
							<li>Dostęp do elementów w LinkedListach jest O(n), a wyszukiwanie O(n).</li>
						</ul>
					</small>
				</section>

				<section>
					<h3>Set&ltE&gt</h3>
					<small>Interfejs Set w języku Java reprezentuje kolekcję unikalnych elementów, bez określonej
						kolejności. Oznacza to, że
						elementy w Set nie mogą się powtarzać.</small>
					<small>Interfejs Set&ltE&gt oprócz metod pochodzących z interfejsu Collection&ltE&gt posiada
						wyłącznie metody wytwórze, np.:
					</small>
					<pre style="font-size: 18px" data-id="code-animation">
	<code class="hljs java" data-trim data-line-numbers>
		<script type="text/template">
static <E> Set<E> of(E e1) 
static <E> Set<E> of(E e1, E e2)
static <E> Set<E> of(E... elements) 
</script></code></pre>
				</section>
				<section>
					<h3>HashSet&ltE&gt</h3>
					<p>
						reprezentuje zbiór nieuporządkowany, w którym elementy są przechowywane w tablicy
						skrótów (hash table). Zbiór
						ten nie gwarantuje, że elementy będą przechowywane w jakiejkolwiek określonej kolejności, ale
						zapewnia, że każdy element
						jest unikalny i posiada wyznaczalny hash code.
					</p>
				</section>
				<section>
					<h3>TreeSet&ltE&gt</h3>
					<p>
						reprezentuje zbiór uporządkowany, w którym elementy są przechowywane w drzewie
						czerwono-czarnym. Zbiór ten
						zapewnia, że elementy są przechowywane w porządku naturalnym (według relacji "mniejszy/równy"),
						a każdy element jest
						unikalny. TreeSet oferuje także dodatkowe metody, umożliwiające dostęp do pierwszego i
						ostatniego elementu w zbiorze, a
						także do elementów znajdujących się przed lub po danym elemencie.
					</p>
				</section>
				<section>
					<h3>LinkedHashSet&ltE&gt</h3>
					<p>
						reprezentuje zbiór uporządkowany, w którym elementy są przechowywane w
						kolejności dodania. Zbiór ten
						łączy funkcjonalności HashSet i List, oferując unikalność elementów oraz zachowanie kolejności
						dodania.
					</p>
				</section>
				<section>

					<h3>Queue&ltE&gt</h3>
					<small>
						<a href="https://youtu.be/0V9Ua538jMI?t=223">Jak to wymawiać?</a>
					</small>
					<p>
						Interfejs Queue w języku Java reprezentuje kolejkę, czyli strukturę danych, w której elementy są
						przechowywane w
						kolejności, w jakiej zostały dodane, a pobierane są w kolejności, w jakiej zostały dodane.
						Kolejka jest strukturą typu
						FIFO (First In, First Out), co oznacza, że element, który pierwszy został dodany do kolejki,
						jest też jako pierwszy
						pobierany z kolejki.
					</p>
				</section>
				<section>
					<h3>
						Queue&ltE&gt
					</h3>
					<pre style="font-size: 18px" data-id="code-animation">
					<code class="hljs java" data-trim data-line-numbers><script type="text/template">
// dodaje element do kolejki. Zwraca true, jeśli element został pomyślnie dodany, a false, jeśli dodanie elementu jest niemożliwe (np. w przypadku pełnej kolejki).
boolean add(E element)

// dodaje element do kolejki. Zwraca true, jeśli element został pomyślnie dodany, a false, jeśli dodanie elementu jest niemożliwe (np. w przypadku pełnej kolejki).
boolean offer(E element)

// pobiera i usuwa element znajdujący się na początku kolejki. Rzuca wyjątek NoSuchElementException, jeśli kolejka jest pusta.
E remove()

// pobiera i usuwa element znajdujący się na początku kolejki. Zwraca null, jeśli kolejka jest pusta.
E poll()

// pobiera, ale nie usuwa element znajdujący się na początku kolejki. Rzuca wyjątek NoSuchElementException, jeśli kolejka jest pusta.
E element()

// pobiera, ale nie usuwa element znajdujący się na początku kolejki. Zwraca null, jeśli kolejka jest pusta.
E peek()
						</script></code></pre>
				</section>
				<section>
					<h3>
						Deueue&ltE&gt
					</h3>
					<small>
						to skrót od "Double Ended Queue", czyli kolejkę dwukierunkową. Deque rozszerza interfejs Queue,
						a więc dziedziczy po nim
						wszystkie jego metody. Dodatkowo, Deque oferuje także metody umożliwiające dodawanie i usuwanie
						elementów zarówno z
						początku, jak i z końca kolejki. Dzięki temu, w przeciwieństwie do zwykłej kolejki, Deque
						pozwala na dodawanie i
						usuwanie elementów z dowolnego końca struktury.
					</small>
				</section>
				<section>
					<h3>BlockingQueue&ltE&gt</h3>
					<small>
						to interfejs, który oferuje metody blokujące. Metody te umożliwiają wątkowi czekanie na elementy
						w kolejce, jeśli
						kolejka jest pusta, lub czekanie na wolne miejsce w kolejce, jeśli kolejka jest pełna.
						Najważniejsze metody to put(E e),
						które umożliwia dodanie elementu do kolejki, ale jeśli kolejka jest pełna, to metoda zawiesza
						wątek wywołujący put(E e)
						aż do momentu, gdy miejsce w kolejce się zwolni. Metoda take() pobiera element z kolejki, ale
						jeśli kolejka jest pusta,
						to metoda zawiesza wątek wywołujący take() aż do momentu, gdy element pojawi się w kolejce.
						Metody BlockingQueue są
						często wykorzystywane w aplikacjach wielowątkowych, w których wątki muszą synchronizować swoje
						działania.
					</small>

				</section>
				<section>
					<h3>TransferQueue&ltE&gt</h3>
					<small>
						to interfejs, który rozszerza interfejs BlockingQueue. TransferQueue oferuje dodatkowe metody
						umożliwiające bezpieczne
						przekazywanie elementów między wątkami.

						W BlockingQueue wątek, który chce dodać element do kolejki lub pobrać element z kolejki, może
						zostać zablokowany, jeśli
						kolejka jest pełna lub pusta, odpowiednio. Natomiast w TransferQueue dodanie elementu do kolejki
						może być zablokowane,
						jeśli nie ma wątku, który czeka na element, który ma być dodany, a pobranie elementu z kolejki
						może być zablokowane,
						jeśli nie ma elementu, który ma zostać pobrany.

						Metoda put() w BlockingQueue będzie blokować wątek, aż element zostanie dodany do kolejki,
						natomiast metoda transfer() w
						TransferQueue będzie blokować wątek, aż element zostanie pobrany z kolejki lub do kolejki
						zostanie dodany wątek, który
						będzie oczekiwał na element.
					</small>
				</section>
				<section>
					<h3>Map&ltK, V&gt</h3>
					<small>
						Interfejs Map w języku Java reprezentuje strukturę danych, która przechowuje pary klucz-wartość.
						Każdy klucz musi być
						unikalny w ramach mapy, a wartość może być dowolnym obiektem. Interfejs Map zawiera wiele metod,
						które umożliwiają
						manipulowanie danymi w mapie, takie jak:
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
																					// dodaje element o kluczu key i wartości value do mapy. Zwraca 
																					// poprzednią wartość przypisaną do klucza, lub null jeśli klucz 
																					// nie był wcześniej przypisany do żadnej wartości.
																					void put(K key, V value)
																					
																					// zwraca wartość przypisaną do klucza key, lub null jeśli klucz nie 
																					// istnieje w mapie.
																					V get(Object key)
																					
																					// usuwa element o kluczu key z mapy i zwraca wartość, która była związana 
																					// z tym kluczem, lub null jeśli klucz nie istnieje w mapie.
																					V remove(Object key)
																					
																					// zwraca true, jeśli mapa zawiera klucz key, lub false w przeciwnym 
																					// przypadku.
																					boolean containsKey(Object key)
																					
																					//  zwraca true, jeśli mapa zawiera wartość value, lub false w przeciwnym 
																					// przypadku.
																					boolean containsValue(Object value)

																					// zwraca liczbę elementów w mapie.
																					int size()

																					// zwraca true, jeśli mapa jest pusta, lub false w przeciwnym 
																					// przypadku.
																					boolean isEmpty()
																					
																					// zwraca zbiór kluczy zawartych w mapie.
																					Set<K> keySet()
																					
																					// zwraca kolekcję wartości zawartych w mapie.
																					Collection<V> values()
																					
																					// zwraca zbiór obiektów typu Map.Entry, reprezentujących pary 
																					// klucz-wartość znajdujące się w mapie.
																					Set<Map.Entry<K,V>> entrySet()
																					</script></code></pre>
				</section>
				<section>
					<h3>HashMap&ltE&gt, TreeMap&ltE&gt i LinkedHashMap&ltE&gt</h3>
					<small>
						<ul>
							<li>HashMap to implementacja Map, która nie gwarantuje zachowania kolejności elementów.
								Elementy
								są przechowywane w taki
								sposób, aby umożliwić szybki dostęp do nich za pomocą klucza. TreeMap natomiast
								przechowuje
								elementy w drzewie, które
								jest posortowane według klucza. LinkedHashMap zachowuje kolejność elementów taką, jaką
								miała
								podczas dodawania.</li>
							<li>HashMap ma złożoność czasową O(1) dla operacji dodawania, usuwania i wyszukiwania
								elementów,
								pod warunkiem, że funkcja
								mieszająca (ang. hash function) działa dobrze i klucze są dobrze rozłożone w tablicy
								mieszającej. TreeMap ma złożoność
								czasową O(log n) dla tych samych operacji, a LinkedHashMap ma nieco gorszą złożoność
								czasową
								O(1) dla dodawania,
								usuwania i wyszukiwania elementów w porównaniu do HashMap, ale lepszą niż TreeMap.</li>
							<li>
								W przypadku HashMap i LinkedHashMap, kolejność elementów nie jest gwarantowana i może
								ulec
								zmianie w czasie, natomiast
								TreeMap gwarantuje posortowanie elementów według klucza.
							</li>
							<li>
								LinkedHashMap pozwala na iterowanie po elementach w kolejności dodania, co może być
								przydatne w niektórych sytuacjach.
							</li>
						</ul>
					</small>
				</section>
				<section>
					<h3>Repozytorium z testami kolekcji</h3>
					<a href="https://github.com/Kajkitsu/Java_collection_tests">Link</a>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Rozważ użycie interfejsów Set, List, Queue i Map dla każdego z
						następujących przypadków (zobacz specyfikację Java API). Ustal, który z
						nich jest najbardziej odpowiedni oraz wyjaśnij, jak użyć go w
						implementacji.
						<ul>
							<li>Pewna firma chce odpowiednio zapisać swoich klientów. Każdego miesiąca będą
								oni losowo wybierani aby otrzymać mały upominek. Trzeba wybrać strukturę danych
								odpowiednią dla losowania.</li>
							<li>Ta sama firma chce ponazywać produkty imionami swoich pracowników. Każde
								imię będzie użyte tylko raz. Trzeba przygotować listę imion.</li>
							<li>W końcu firma ta zdecydowała się użyć tylko najczęściej występujących imion
								swoich pracowników do nazwania produktów. Policzono ilu pracowników posiada
								dane imię. Trzeba przygotować listę imion.</li>
							<li>
								Firma chce rozprowadzić bilety na mecze lokalnej drużyny siatkarskiej. Trzeba
								skonstruować odpowiednią listę oczekujących.
							</li>
						</ul>
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Napisz program, który będzie losował nazwiska klientów z listy (zobacz
						punkt 1. poprzedniego zadania), a następnie je usuwał. Dokładniej,
						zaimplementuj klasę Names z obiektowym
						atrybutem names odpowiadającym wspomnianej liście i z obiektową
						metodą choose(), która zwraca losowo wybrane nazwisko z
						listy names usuwając je jednocześnie.
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 3</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Napisz program, który będzie wybierał najczęściej występujące imiona
						klientów z listy (zobacz punkt 3. zadania 1.), a następnie je
						usuwał. Dokładniej, zaimplementuj klasę FrequentNames z obiektowym
						atrybutem frequentNames i z obiektową metodą choose(), która zwraca
						najczęściej występujące imię z listy frequentNames usuwając je
						jednocześnie, oraz metodę insert(String name) wstawiającą imię do
						danej listy
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 4</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj listy jednokierunkowe zawierające liczby całkowite
						(typ int) bez użycia kolekcji. Lista ma się składać z kotwicy, tj. obiektu
						klasy Anchor, oraz elementów, tj. obiektów klasy Element. Obiekty klasy
						Element mają posiadać atrybut val typu int oraz opcjonalnie wskaźnik na
						następny element listy, dokładniej obiekt klasy Element. Klasa Anchor ma
						posiadać atrybut first typu Element wskazujący na pierwszy element listy
						oraz metody:
						<ul>
							<li>insertAtTheFront(int x) - wstawiającą liczbę x na początek listy</li>
							<li>insertAtTheEnd(int x) - wstawiającą liczbę x na koniec listy</li>
							<li>removeFirst() - usuwającą pierwszy element listy</li>
							<li>removeLast() - usuwającą ostatni element listy</li>
							<li>toString() - zwracająca string reprezentujący daną listę</li>
							<li>equals(Object o) - sprawdzającą, czy dwie listy zawierają dokładnie te same liczby w
								tym samym porządku; jeśli tak, ma ona zwracać true, w przeciwnym wypadku false</li>
						</ul>
					</small>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(30deg, #29558b, #2da169)">
				<section>
					<h2>Lab 5-6</h2>
					<h3>Metody i atrybuty statyczne. Wyjątki</h3>
				</section>
				<section>
					<h3>Pola (atrybuty) statyczne</h3>
					<small>Pola statyczne są współdzielone przez wszystkie obiekty klasy i są inicjowane tylko raz, gdy
						klasa jest ładowana przez
						maszynę wirtualną. W przeciwieństwie do pól niestatycznych, pola statyczne mogą być odczytywane
						i modyfikowane bez
						tworzenia instancji klasy. Są one często używane do przechowywania danych, które są wspólne dla
						wszystkich obiektów
						klasy, np. stałych lub liczników.</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
public class Counter {
    private static int count = 0; // pole statyczne

    public Counter() {
        count++; // inkrementuj pole statyczne przy tworzeniu nowego obiektu
    }

    public static int getCount() { // metoda statyczna
        return count;
    }
}
</script></code></pre>
				</section>
				<section>
					<h3>Metody statyczne</h3>
					<small>
						Meotdy statyczne to takie, które działają na poziomie klasy, a nie na poziomie obiektów. Metody
						te są zwykle używane do wykonania
						operacji, które nie wymagają dostępu do pól niestatycznych i które nie są związane z określonymi
						instancjami klasy.
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
public class MathUtil {
    public static int factorial(int n) {
        int result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }
}
										</script></code></pre>
					<small>
						W tym przykładzie metoda <b><em>factorial()</em></b> oblicza silnię liczby całkowitej i jest
						zdefiniowana jako metoda statyczna. Możemy
						jej używać bez tworzenia instancji klasy, <br /> np. <b><em>int result =
								MathUtil.factorial(5);</em></b>
					</small>
				</section>
				<section>
					<h3>Wyjątki</h3>
					<small>Wyjątki w języku Java to mechanizm pozwalający na obsługę błędów i wyjątkowych sytuacji
						podczas wykonywania programu. W
						momencie wystąpienia błędu w czasie działania programu, maszyna wirtualna Javy generuje wyjątek
						(exception), który
						przerywa normalny przepływ wykonywania kodu i przechodzi do bloku kodu obsługi wyjątku.</small>
					<img src="assets/exceptions.png">

				</section>
				<section>
					<h3>Obsługa wyjątków</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
try {
    // kod, który może rzucić wyjątek
} catch (ExceptionType e) {
    // kod obsługi wyjątku
} finally {
    // kod, który zostanie wykonany zawsze, 
		// niezależnie od wystąpienia wyjątku
}

																				</script></code></pre>
					<small>
						Blok <em><b>try</b></em> zawiera kod, który może rzucić wyjątek, a blok <em><b>catch</b></em>
						zawiera kod obsługi wyjątku, który zostanie wykonany tylko
						wtedy, gdy wyjątek zostanie rzucony. Blok <em><b>finally</b></em> zawiera kod, który zostanie
						wykonany zawsze, niezależnie od tego, czy
						wyjątek został rzucony czy nie.
					</small>
				</section>
				<section>
					<h3>Propagacja wyjątków</h3>
					<small>
						Gdy wyjątek jest zgłaszany przez metodę, to metoda może albo obsłużyć wyjątek (przy użyciu bloku
						<em><b>try-catch</b></em>), albo
						przekazać wyjątek wyżej w stosie wywołań do wywołującej metodę. Jeśli wyjątek nie jest obsłużony
						przez żadną metodę na
						stosie wywołań, to program kończy działanie, a wyjątek jest wyświetlany w konsoli.
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
								try {
            try {
                System.out.println("Chyba wszystko OK"); //instrukcja się nie wykona
                throw new ParseException("Błąd parsowania", 1); // Tu mamy wyjątek (ParseException) - przerwanie bloku try
            } catch (ClassCastException e) { // Nie pasuje
                e.printStackTrace();
            } catch (NumberFormatException e) { // Nie pasuje - przerywa blok try!!!
                e.printStackTrace();
            }
        } catch (NullPointerException e) { // Nie pasuje
            e.printStackTrace();
        } catch (RuntimeException e) { // Nie pasuje
            e.printStackTrace();
        } catch (Exception e) { // Pasuje wykonanie bloku catch
            System.out.println("O! to sie wykona");
            e.printStackTrace();
        }
</script></code></pre>
				</section>
				<section>
					<h3>Deklarowanie własnych wyjątków</h3>
					<small>Deklarowanie własnych wyjątków w Javie pozwala na obsługę wyjątków niestandardowych, czyli
						takich, które nie są zdefiniowane w standardowej bibliotece Javy.</small>
					<br style="margin-top: 20px;" />
					<small>
						Aby zadeklarować własny wyjątek w Javie, należy stworzyć nową klasę, która rozszerza klasę
						<em><b>Exception</b></em> lub jedną z jej podklas. Należy zdefiniować konstruktor, który
						przekazuje wiadomość do klasy bazowej za pomocą słowa kluczowego <em><b>super</b></em>.
						Następnie można dodać dodatkowe pola i metody, które pomogą w obsłudze wyjątku.</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj klasę <em><b>Factorial</b></em> (silnia) z metodą <em><b>factorial(int x)</b></em>
						liczącą silnię x. Jaką
						sygnaturę powinna mieć ta
						metoda.
						<ol type="A">
							<li>Zachowując tę sygnaturę, zmodyfikuj tę implementację tak, aby dla <em><b>x &lt
										0</b></em> metoda nie
								zwracała wartości</li>
							<li>
								Zaimplementuj metodę factorial1, która dla liczb ujemnych będzie rzucać wyjątek
								<em><b>MyException</b></em>. <em><b>MyException</b></em> ma bezpośrednio
								rozszerzać <em><b>Exception</b></em>. Jak trzeba zmienić sygnaturę metody
								<em><b>factorial</b></em>?
							</li>
							<li>
								Jaka jest różnica pomiędzy tym a poprzednim rodzajem wyjątków?
							</li>
							<li>
								Przetestuj obie metody implementując metodę main tak, żeby w niej metody były sprawdzane
								dla ciągu argumentów typu:
								<em><b>-3, -1, 0, 1, 2, 4, 5</b></em>. Wskazówka: można użyć metody
								<em><b>toString</b></em>.
							<li>
								Użyj metody printStackTrace do pokazania zawartości stosu wywołań w momencie rzucania
								wyjątku.
							</li>
						</ol>
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj klasę <em><b>DoTrzechRazySztuka</b></em>, która sczytuje z konsoli liczbę
						<em><b>float</b></em> i
						wypisuje ją w postaci np. <em><b>x = 1.2</b></em>
						(zobacz slajdy z pierwszego wykładu). Metoda ta powinna dopuszczać maksymalnie dwa błędy w typie
						danych, np. jeśli
						podczas pierwszej próby wpisany będzie string <em><b>abc</b></em>, to jest to błąd i metoda
						powinna
						zażądać innej danej i tak
						maksymalnie dwa razy. Metoda ma kończyć swoje wykonanie po pierwszym wprowadzeniu
						<em><b>float</b></em>
						lub po trzech nieudanych
						próbach.
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 3</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj klasy <em><b>Point</b></em>, <em><b>Line</b></em>, <em><b>Polygon</b></em>,
						<em><b>Group</b></em>. Przedostatnia klasa ma implementować wielokąty wyznaczone przez pewną
						liczbę punktów. Ostatnia klasa ma implementować grupy figur (jak w przypadku edytorów typu
						PowerPoint). Wszystkie klasy
						mają implementować interfejs <em><b>Figur</b></em> (lub klasę abstrakcyjną z abstrakcyjnymi
						metodami min. <em><b>equals(Object o)</b></em> żeby wymusić
						nadpisanie). Zaimplementuj również klasę <em><b>Group</b></em> grupująca figury i również
						implementującą <em><b>Figure</b></em>. <em><b>Figure</b></em> ma posiadać
						metody:
						<br />
						<ol>
							<li><em><b>move(double dx, double dy)</b></em> przesuwającą daną figurę</li>
							<li><em><b>flip()</b></em> przerzucająca dana figurę</li>
							<li><em><b>equals(Object o)</b></em> sprawdzającą, czy figury są równe</li>
							<li><em><b>toString()</b></em> zwracająca łańcuch znaków (String) reprezentujący daną figurę
							</li>
						</ol>
					</small>
				</section>

			</section>
			<section data-background-gradient="linear-gradient(60deg, #606623, #753660)">
				<section>
					<h2>Lab 7-8</h2>
					<h3>Operacja na kolekcjach z użyciem strumieni</h3>
				</section>
				<section>
					<h3>Programowanie funkcjonalne w Javie cz.1</h3>
					<small style="margin: 20px;">
						Programowanie funkcjonalne w Javie jest paradygmatem programowania, w którym skupiamy się na
						tworzeniu programów poprzez składanie funkcji i operacji. W przeciwieństwie do programowania
						proceduralnego, programowanie funkcjonalne kładzie nacisk na niemutowalność danych i unikanie
						efektów ubocznych.</small>
					<small style="margin: 20px;">Na przestrzeni czasu, wsparcie dla programowania funkcjonalnego w Javie
						uległo znacznemu
						rozwojowi. Wprowadzenie funkcji lambda w Javie 8 stanowiło przełomową zmianę, umożliwiając
						programistom pisanie kodu w bardziej deklaratywny sposób. Funkcje lambda pozwalają na
						przekazywanie funkcji jako argumentów do innych funkcji oraz tworzenie anonimowych funkcji, co
						jest niezwykle przydatne w programowaniu funkcjonalnym.</small>
					<small style="margin: 20px;">Dodatkowo, Javie 8 wprowadziło strumienie (streams), które umożliwiają
						operacje sekwencyjne i
						równoległe na zbiorach danych. Strumienie w Javie dostarczają wiele funkcji pośrednich i
						końcowych, które można łączyć w celu manipulacji i przetwarzania danych w sposób bardziej
						funkcyjny. Wykorzystanie strumieni pozwala programistom unikać pętli for i for-each, co
						przyczynia się do bardziej czytelnego i modułowego kodu.</small>
				</section>
				<section>
					<h3>Programowanie funkcjonalne w Javie cz.2</h3>
					<small style="margin: 20px;">Kolejne wersje Javy wprowadzały również nowe funkcjonalności i
						usprawnienia związane z
						programowaniem funkcjonalnym. Java 9 wprowadziła prywatne metody interfejsów, które umożliwiają
						bardziej czytelną i modułową implementację interfejsów funkcyjnych. Java 10 wprowadziła kolekcje
						niezmiennych (immutable collections), które są zgodne z zasadami programowania funkcjonalnego.
						Wersje Javy 11 i 12 skupiały się na optymalizacji wydajności operacji na strumieniach oraz
						wprowadzały dodatkowe usprawnienia w dziedzinie programowania funkcyjnego.</small>
					<small style="margin: 20px;">
						Warto zwrócić uwagę na inny język programowania oparty o JVM: Scale. W której programowanie
						funkcyjne jest jej integralną częścią. Scala oferuje wiele funkcji i konstrukcji, które
						umożliwiają programowanie funkcyjne. Przykładem jest mechanizm funkcji anonimowych, który
						pozwala na definiowanie funkcji bez nadawania im nazwy. Funkcje anonimowe są powszechnie
						wykorzystywane w programowaniu funkcyjnym, umożliwiając przekazywanie ich jako argumentów do
						innych funkcji oraz tworzenie wyrażeń lambda. Dodatkowo, w Scala istnieje wiele bibliotek i
						frameworków, które wspierają programowanie funkcyjne w skali. Przykładem jest Apache Spark,
						który został napisany w Scali i wykorzystuje jej funkcyjne podejście do przetwarzania dużych
						zbiorów danych.
					</small>
				</section>
				<section>
					<h3>Optional&ltT&gt</h3>
					<p>W podejściu funkcyjnym unikamy bezpośredniego używania referencji na
						null. Jeśli chcemy zaznaczyć, że referencja jest opcjonalna, to używamy typu
						Optional, który jest kontenerem dla obiektu dowolnego typu.</p>
					<p>Referencja na typ Optional nigdy nie powinna być nullem, obiekty Optional
						tworzymy przy pomocy statycznych metod</p>
					<p> <a
							href="https://raw.githubusercontent.com/Kajkitsu/Java_collection_tests/master/src/test/java/org/example/OptionalTest.java">Testy
							wprowadzające do Optional</a>
					</p>

				</section>
				<section>
					<h3>Stream&ltT&gt</h3>
					<small>Programowanie funkcyjne jest zorientowane na wysokopoziomowe
						przetwarzanie danych, ze względu na powtarzające się wzorce
						przetwarzania danych.
					</small>
					<small>
						Strumień w Javie stanowi abstrakcję sekwencji danych, która może
						być procedowana w dowolny sposób zgodnie z ustalonymi
						operacjami, i w odpowiedniej kolejności.
					</small>
					<small>
						Produktem przetwarzania strumienia może być:
						<ul>
							<li>pojedynczy obiekt - mówimy wtedy o agregacji lub redukcji
								danych, np. największy element, łączna liczba elementów,
								łańcuch znaków,</li>
							<li>wiele obiektów, które niekoniecznie są tego samego typu co
								oryginalny strumień, np. kolekcja, tablica.</li>
						</ul>
					</small>
					<small>
						Strumienie są <b>ewaluowane leniwie</b>, czyli nie wykonują żadnych
						operacji tak długo, jak to nie jest wymagane.

					</small>
				</section>
				<section>
					<h3>Tworzenie strumieni</h3>
					<small>W zależności od źródła danych strumienie mogą być skończone albo nieskończone.
						<ul>
							<li><b>Skończone strumienie</b> - bazują na typach o określonej liczbie elementów, takich
								jak
								tablice, kolekcje dowolnego typu, rekordy w bazie danych.
								<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" ><script type="text/template">
Stream<String> empty = Stream.empty();
Stream<Integer> singleElement = Stream.of(1);
Stream<Integer> fromArray = Stream.of(1, 2, 3);
var list = List.of("a", "b", "c");
Stream<String> fromList = list.stream();
	</script></code></pre>
							</li>
							<li><b>Nieskończone strumienie</b> - generują dane w nieskończoność na podstawie
								określonego wzorca.
								<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" ><script type="text/template">
IntStream intStream = new Random().ints();
// przyjmuje lambdę typu Supplier
Stream<Integer> zeroGenerator = Stream.generate(() -> 0);
// przyjmuje dwa argumenty - wartość początkową, i lambdę typu UnaryOperator
// zwracającą kolejny obiekt na podstawie poprzedniego
Stream<Integer> evenNumbersGenerator = Stream.iterate(0, num -> num + 2);
										</script></code></pre>
							</li>
						</ul>
					</small>
				</section>
				<section>
					<h3>Typu operacji na strumieniach</h3>
					<small>
						<ol>
							<li><b>Utworzenie strumienia na podstawie źródła</b> - zawsze zwraca typ
								Stream z odpowiednim typem w miejscu typu generycznego.
								Wyjątkiem są strumienie specjalizowane dla typów prymitywnych.</li>
							<li><b>Operacje pośrednie</b> - przeprowadzają pewnego rodzaju transformację
								strumienia w nową postać zawierającą dodatkową operację. Operacje
								tego typu łączą się w łańcuch, który może odfiltrowywać niechciane
								obiekty, sortowaćje według ustalonego, oraz konwertować wartości w
								obiektach. Dopóki nie zostanie ustalona operacja terminująca, żadna
								operacja pośrednia się nie wykona.</li>
							<li><b>Operacja terminująca</b> - produkuje ostateczny rezultat przetwarzania,
								który może mieć postać zredukowaną (zagregowaną) do pojedynczego
								obiektu lub tworzyć nową kolekcję, tablicę, itp.</li>
						</ol>
					</small>
					<small style="margin: 20px;">Strumień kończy działanie po operacji terminującej i jego ponowne
						użycie
						jest wtedy niemożliwe.</small>
					<small style="margin: 20px;">Operacje łączymy w jeden ciąg wywołań, co jest możliwe dzięki temu, że
						każda operacja pośrednia zwraca typ Stream.</small>
					<small> <a
							href="https://raw.githubusercontent.com/Kajkitsu/Java_collection_tests/master/src/test/java/org/example/StreamTest.java">Testy
							wprowadzające do Stream </a></small>


				</section>

				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Większość problemów zapisanych w formie imperatywnej “jak to ma się stać” możemy zapisać przy
						pomocy
						podejścia funkcyjnego “co ma zostać zrobione”.
						Przepisz poniższą funkcję, używając podejścia funkcyjnego. Wykorzystaj klasę IntStream do
						wygenerowa‐
						nia strumienia liczb.
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" ><script type="text/template">
static int calculateSumOfSquaresInRange(int startInclusive, int endInclusive) {
	if (endInclusive < startInclusive) {
		throw new InvalidRangeException();
	}

	int sumOfSquares = 0;
	for (int i = startInclusive; i <= endInclusive; i++) {
		sumOfSquares += i * i;
	}
	return sumOfSquares;
}
</script></code></pre>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2 cz.1</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj metody pozwalające pobierać informacje na temat użytkowników z pewnego źródła. Do
						implementacji wykorzystaj podejście funkcyjne z użyciem strumieni.
					</small>
					<small>Model użytkownika jest następujący:</small>

					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" ><script type="text/template">record User(Long id, String firstName, String lastName,
		    Integer age, List<Privilege> privileges) {

	@Override
	public boolean equals(Object obj) {
		if (obj instanceof User user) {
			Objects.equals(this.id, user.id);
		}
		return false;
	}

	@Override
	public int hashCode() {
		return Objects.hash(this.id);
	}
}

enum Privilege {
	CREATE, UPDATE, READ, DELETE
}
</script></code></pre>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2 cz.2</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Serwis do zaimplementowania jest następujący:
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" ><script type="text/template">interface UsersService {
	List<User> sourceUsers = List.of(
			new User(1L, "John", "Smith", 26, List.of(Privilege.UPDATE)),
			new User(2L, "Greg", "Jonson", 30,
					List.of(Privilege.UPDATE, Privilege.CREATE, Privilege.DELETE)),
			new User(3L, "Alex", "Smith", 13, List.of(Privilege.DELETE)));

	List<Privilege> getAllDistinctPrivileges();

	Optional<User> getUpdateUserWithAgeHigherThan(int age);

	Map<String, Long> getNumberOfLastNames();

	List<User> sortByAgeDescAndNameAsc();
	
	Map<Integer, List<User>> groupByCountOfPrivileges();

	Map<Privilege, List<User>> groupByPrivileges();
}
</script></code></pre>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 3 cz. 1</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj klasyczną grę w wojnę.
						Rozpocznij od wygenerowania talii 52 kart, zgodną z następującym modelem.
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" ><script type="text/template">interface UsersService {record GameCard(int rank, CardSuit cardSuit) {}

enum CardSuit {
	HEARTS,
	TILES,
	CLOVERS,
	PIKES
}</script></code></pre>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Użyj metody Collections.shuffle, aby spowodować przetasowanie kart. Następnie “rozłóż” karty na
						dwie równe kupki do kolekcji reprezentujących talie dwóch graczy:
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" ><script type="text/template">interface UsersService {record GameCard(int rank, CardSuit cardSuit) {}
LinkedList<GameCard> firstPlayerCards = new LinkedList<>();
LinkedList<GameCard> secondPlayerCards = new LinkedList<>();</script></code></pre>
					<small style="text-align: left; margin-left: 30px; margin-top: 20px" style="text-align: left;">
						Dlaczego używamy LinkedList w implementacji? Czy możemy użyć innej?
						Następnie zaimplementuj symulację rozgrywki zgodnie z następującym opisem:
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 3 cz. 2</h3>

					<small style="text-align: left; margin-left: 30px; margin-top: 20px" style="text-align: left;">
						Zawodnicy równocześnie wykładają po jednej karcie i porównują ich wartości (względem
						starszeństwa – kolory nie odgrywają roli). Gracz mający kartę o wyższej wartości odbiera karty i
						kładzie je pod spodem swojej talii.
					</small>
					<small style="text-align: left; margin-left: 30px; margin-top: 20px" style="text-align: left;">
						Zawodnicy równocześnie wykładają po jednej karcie i porównują ich wartości (względem
						starszeństwa – kolory nie odgrywają roli). Gracz mający kartę o wyższej wartości odbiera karty i
						kładzie je pod spodem swojej talii.
					</small>
					<small style="text-align: left; margin-left: 30px; margin-top: 20px" style="text-align: left;">
						Jeśli karty mają taką samą siłę (as na asa, król na króla, itp.), rozpętuje się wojna; należy
						odkryć po
						jednej karcie, położyć je koszulkami do góry na swoich kartach odkrytych, a następnie wyciągnąć
						następną kartę, położyć odkryte na zakrytych kartach i wówczas są one porównywane. Karta o
						wyższej wartości wygrywa, a zwycięzca wojny odbiera wszystkie karty wykorzystane w wojnie.
						Proces jest powtarzany, jeśli w okresie wojny znowu nie można wyłonić zwycięzcy.
						Wygrywa ten, kto pierwszy zabierze wszystkie karty przeciwnikowi.
					</small>
					<small style="text-align: left; margin-left: 30px; margin-top: 10px" style="text-align: left;">
						Dodatkowo zliczaj liczbę tur, jakie zostały wykonane, aby wyłonić zwycięzcę. Czy to się uda?
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3 style="color: #ce0707;">Zadanie domowe</h3>
					<p style="text-align: left; margin-left: 30px; margin-top: 20px;">
						Przed kolejnymi zajęciami przećwicz indywidualnie integrację z zewnętrznym API, która jest
						opisana w kolejnej sekcji.
					</p>
				</section>

			</section>
			<section data-background-gradient="linear-gradient(60deg, #606623, #753660)">
				<section>
					<h2>Lab 9-10</h2>
					<h3>Pokemony i inne stwory 👻</h3>
				</section>
				<section>
					<h3>Interfejs API</h3>
					<small style="margin: 10px;">Interfejs API (Application Programming Interface) to zbiór
						zdefiniowanych reguł i protokołów,
						które umożliwiają komunikację i integrację między różnymi programami lub aplikacjami. API
						definiuje, jak programy mogą komunikować się ze sobą, jakie operacje można wykonać oraz jak
						przekazywać dane.</small>

					<small style="margin: 10px;">Interfejs API działa na zasadzie umożliwiania jednemu programowi
						(nazywanemu klientem)
						korzystanie z funkcji lub danych udostępnionych przez inny program (nazywanego serwerem). Klient
						wysyła zapytania do serwera, a serwer odpowiada na te zapytania, udostępniając żądane informacje
						lub wykonując żądane operacje.</small>
					<small style="margin: 10px;">API może przyjmować różne formy, takie jak REST (Representational State
						Transfer), SOAP (Simple Object Access Protocol) lub GraphQL. RESTful API jest obecnie jednym z
						najpopularniejszych i szeroko stosowanych rodzajów interfejsów API. Oferuje ona zestaw zasad,
						które definiują sposoby dostępu do zasobów za pomocą standardowych metod protokołu HTTP, takich
						jak GET, POST, PUT i DELETE.
					</small>
					<small style="margin: 10px;">Interfejsy API są szeroko stosowane w dziedzinie programowania
						aplikacji, zarówno na poziomie
						internetowych usług, jak i lokalnych aplikacji. Przykłady zastosowań interfejsów API to
						integracja zewnętrznych usług, jak płatności online czy serwisy mapowe, pobieranie i
						udostępnianie danych z baz danych lub serwisów internetowych, automatyzacja zadań za pomocą
						skryptów i wiele innych.</small>
					<small>Dzięki interfejsom API programiści mogą tworzyć aplikacje, które wykorzystują funkcjonalności
						lub dane udostępniane przez inne systemy, bez konieczności ponownego wynajdywania koła i
						tworzenia wszystkiego od zera. Interfejsy API są kluczowe dla tworzenia zintegrowanych i
						elastycznych systemów informatycznych.</small>
				</section>
				<section>
					<h3>Publiczne API</h3>
					<p>W internecie dostępnych jest szerege publicznych darmowych Rest API. Przykładowa lista znajduje
						się <a href="https://github.com/public-apis/public-apis">tutaj</a>. Są one idealną możliwością
						do przećwiczenia integrowania naszych aplikacji z zewnętrznymi serwisami.</p>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie?</h3>
					<p>Ostatnie zadanie laboratoryjne będzie polegało na skorzystaniu z zewnetrznego API i
						wyciągniecie za jego pomocą pewnych informacji. Czas realizacji zadania będzie ograniczony, tzn.
						do końca trwania laboratoriów.</p>
					<p>Na następnych slajdach zostało przygotowane przykładowe zadanie, które ma wdrożyć w korzystanie z
						zewnętrznego i ułatwić wykonanie ostatniego zadania.</p>

				</section>
				<section>
					<h3>Przykładowe Zadanie</h3>
					<p>Używając <a href="The Rick and Morty API">The Rick and Morty API</a> opracuj program
						umożliwiający sprawdzenie, którzy bohaterowie występowaliw tym samym odcinku co podany bohater,
						np. Ogór Rick.
					</p>
					<img src="assets/Pickle_Rick.webp" style="height: 400px;" />
				</section>
				<section>
					<h4>Krok 1. Zapoznanie sie z dokumentacją API</h4>
					<small>Pierwszym krokiem w tego typu zadaniach będzie przeanalizowanie dostępnych endpointów i
						określnie z których należy skorzystać, aby osiągnąć podany cel.</small>

					<small>Zaglądając do dokumentacji dostępnej <a
							href="https://rickandmortyapi.com/documentation">tutaj</a> (do czego mocno zachęcam)
						zauważamy dwa interfejsy API:
						REST i GraphQL. Wybór trafia na REST.</small>
				</section>
				<section>
					<h4>Krok 2. Określenie używanych endopointów</h4>
					<small>Należy, wieć skorzystać z następujących endopointów, aby osiągnąć cel:
						<ol style="margin-top: 10px;">
							<li><a href="https://rickandmortyapi.com/documentation/#filter-characters"><b>Character/Filter
										Character</b></a> - w pierwszym etapie wyszkujemy bohatera o podanej nazwie,
								na poziomie programu musimy zapewnić aby tylko jeden wpis pasował do podanej nazwy.
								W ten sposób uzyskamy informacje o bohaterze, jak i odcinkach w których występował.
								<p style="margin-left: 40px; margin: 15px">
									Ponieważ wszystkie operacje są typu GET, można podejrzeć ich wynik bezpośrednio
									w
									przeglądarce przechodząc pod wskazany adres. Wszystkie odpowiedzi są zwracane w
									formacie JSON.
								</p>
								<p style="margin-left: 40px; margin: 15px">
									Request, który nas nie satysfakcynuje, ponieważ zwraca więcej niż jednego
									bohatera: <a
										href="https://rickandmortyapi.com/api/character/?name=rick">https://rickandmortyapi.com/api/character/?name=rick</a>
								</p>
								<p style="margin-left: 40px; margin: 15px">
									Request, który nas satysfakcynuje, ponieważ dokładnie jednego bohatera: <a
										href="https://rickandmortyapi.com/api/character/?name=pickle">https://rickandmortyapi.com/api/character/?name=pickle</a>

								</p>
							</li>
							<li><a href="https://rickandmortyapi.com/documentation/#get-a-single-episode"><b>Episode/Single
										Episode</b></a> - Wraz z odpowiedziami z poprzedniego requestu przesłane są
								również ścieżki do odcinków, w których występował bohater.
								<p style="margin-left: 40px; margin: 15px">Przykładowy request <a
										href="https://rickandmortyapi.com/api/episode/24">https://rickandmortyapi.com/api/episode/24</a>
								</p>
							</li>
							<li><a href="https://rickandmortyapi.com/documentation/#get-a-single-character"><b>Character/Single
										Character</b></a> - Wraz z odpowiedziami z poprzedniego requestu przesłane
								są również ścieżki do bohaterów, którzy występowali w tym samym odcinku.

								<p style="margin-left: 40px; margin: 15px">Przykładowy request <a
										href="https://rickandmortyapi.com/api/character/329">https://rickandmortyapi.com/api/character/329</a>
								</p>
							</li>
						</ol>
					</small>
				</section>
				<section>
					<h4>Krok 3. Użycie zwracanych ścieżek do zasobów</h4>
					<small>Zwracanie ścieżki do zasobu przez API jest powszechną praktyką w programowaniu aplikacji
						internetowych. API (Interfejs programowania aplikacji) pozwala na komunikację między różnymi
						systemami lub aplikacjami poprzez udostępnienie zestawu zdefiniowanych endpointów.</small>
					<small>Referencje do powiązanych zasobów mogą być dostarczane w różnych formatach, takich jak adresy
						URL, identyfikatory zasobów lub inne unikalne oznaczenia. Przykładowo, w odpowiedzi na żądanie
						pobrania szczegółów użytkownika, odpowiedź mogłaby zawierać nie tylko informacje o samym
						użytkowniku, ale także odnośniki do innych powiązanych zasobów, takich jak jego zamówienia,
						komentarze lub profil publiczny.</small>
					<small>Dzięki tym referencjom klient API może łatwo nawigować między różnymi zasobami, wykorzystując
						dostępne odnośniki. Na przykład, klient może użyć adresu URL do zamówień, aby pobrać listę
						zamówień danego użytkownika lub wywołać odpowiednie zapytanie w celu złożenia nowego zamówienia
						dla danego użytkownika. </small>
					<small>Zamiast budować ścieżki URL "od zera" skorzystamy właśnie z tych dostarczonych
						referencji.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 4. Pierwsze zapytanie</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers>
<script type="text/template">
	package org.example;
	
	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpHeaders;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	
	public class RickAndMortyFetcher {
		public static void main(String[] args) {
			// Tworzenie instancji HttpClient
			HttpClient httpClient = HttpClient.newHttpClient();
	
			// Adres URL API
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=pickle";
	
			// Tworzenie HttpRequest z adresem URL i parametrem
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(apiUrl))
					.GET()
					.build();
	
			try {
				// Wysłanie żądania GET i przechwycenie odpowiedzi
				HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
	
				// Pobranie statusu odpowiedzi
				int statusCode = response.statusCode();
	
				// Pobranie nagłówków odpowiedzi
				HttpHeaders headers = response.headers();
	
				// Pobranie ciała odpowiedzi
				String responseBody = response.body();
	
				// Wyświetlanie statusu kodu
				System.out.println("Status code: " + statusCode);
	
				// Wyświetlanie nagłówków odpowiedzi
				System.out.println("Response headers: " + headers);
	
				// Wyświetlanie ciała odpowiedzi
				System.out.println("Response body: " + responseBody);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Efektem tego kodu będze wypisanie w terminalu odpowiedzi z serwera
						w formacie JSON. Nie jest to forma, która nasz zadowala, odczytanie nazwy bohatera nie jest
						możliwe, ponieważ wszystkie informacje są zawarte w jednym Stringu.
						Mamy dwie możliwości: skorzystanie z biblioteki umożliwiającej
						operowanie na JSONie za pomocą dostarczonych w jej ramach metod lub skorzystanie z DTO (<a
							href="https://java-design-patterns.com/patterns/data-transfer-object/"> Data Transfer
							Object</a>). Wybór trafia na DTO. Wcześniej jednka dokonajmy reafactoru kodu.</small>
				</section>

				<section data-auto-animate>
					<h4 data-id="code-title">Krok 4. Pierwsze zapytanie</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="9-30">
<script type="text/template">
	package org.example;
	
	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpHeaders;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	
	public class RickAndMortyFetcher {
		public static void main(String[] args) {
			HttpClient httpClient = HttpClient.newHttpClient();
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=pickle";
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(apiUrl))
					.GET()
					.build();
	
			try {
				HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
				int statusCode = response.statusCode();
				HttpHeaders headers = response.headers();
				String responseBody = response.body();
				System.out.println("Status code: " + statusCode);
				System.out.println("Response headers: " + headers);
				System.out.println("Response body: " + responseBody);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Nie ma potrzeby komentowania każdej linijki kodu. Kod powinnien być
						na tyle czytelny, aby "sam" się dokumentował. Komentarze są wskazane wyłącznie, jeżeli mimo
						naszego
						wysiłku kod nie jest czytelny, np. wyjątkow skąplikowana logika działania.</small>
				</section>

				<section data-auto-animate>
					<h4 data-id="code-title">Krok 4. Pierwsze zapytanie</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="11-15|17-38">
<script type="text/template">
	package org.example;

	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpHeaders;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	
	public class RickAndMortyFetcher {

		public static void main(String[] args) {
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=pickle";
			RickAndMortyFetcher fetcher = new RickAndMortyFetcher();
			System.out.println(fetcher.fetch(apiUrl));
		}
	
		public String fetch(String path) {
			HttpClient httpClient = HttpClient.newHttpClient();
			
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(path))
					.GET()
					.build();
	
			try {
				HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
				int statusCode = response.statusCode();
				HttpHeaders headers = response.headers();
				String responseBody = response.body();
				System.out.println("Status code: " + statusCode);
				System.out.println("Response headers: " + headers);
				System.out.println("Response body: " + responseBody);
				return responseBody;
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}

	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Metody powinny być krótkie. Nie ma ściśle określonej długości.
						Cześć logiki należy wynieść poza <em><b>main</b></em>, aby kod był bardziej obiektowy niż
						strukturalny</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 4. Pierwsze zapytanie</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="17-35">
<script type="text/template">
	package org.example;

	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpHeaders;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	
	public class RickAndMortyFetcher {

		public static void main(String[] args) {
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=pickle";
			RickAndMortyFetcher fetcher = new RickAndMortyFetcher();
			System.out.println(fetcher.fetch(apiUrl));
		}
	
		public String fetch(String path) {
			HttpClient httpClient = HttpClient.newHttpClient();
			
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(path))
					.GET()
					.build();
	
			try {
				HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
				int statusCode = response.statusCode();
				HttpHeaders headers = response.headers();
				String responseBody = response.body();
				return responseBody;
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}

	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Komunikaty w terminalu nie są potrzebne.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 4. Pierwsze zapytanie</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="10">
<script type="text/template">
	package org.example;

	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpHeaders;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	
	public class RickAndMortyFetcher {
		private static final HttpClient httpClient = HttpClient.newHttpClient();

		public static void main(String[] args) {
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=pickle";
			RickAndMortyFetcher fetcher = new RickAndMortyFetcher();
			System.out.println(ffetcher.fetch(apiUrl));
		}
	
		public String fetch(String path) {
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(path))
					.GET()
					.build();
	
			try {
				HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
				int statusCode = response.statusCode();
				HttpHeaders headers = response.headers();
				String responseBody = response.body();
				return responseBody;
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}

	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Utworzenie klienta Http jest względnie kosztowną operacją, nie ma
						potrzeby aby za każdym wywołaniem był tworzony nowy klient. W tym momencie należy skorzystać z
						<em><b>private static final</b></em> w terminalu nie są potrzebne.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 4. Pierwsze zapytanie</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="30-33">
<script type="text/template">
	package org.example;

	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpHeaders;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	
	public class RickAndMortyFetcher {
		private static final HttpClient httpClient = HttpClient.newHttpClient();

		public static void main(String[] args) {
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=pickle";
			RickAndMortyFetcher fetcher = new RickAndMortyFetcher();
			System.out.println(fetcher.fetch(apiUrl));
		}
	
		public String fetch(String path) {
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(path))
					.GET()
					.build();
	
			try {
				HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
				int statusCode = response.statusCode();
				HttpHeaders headers = response.headers();
				String responseBody = response.body();
				return responseBody;
			} catch (IOException | InterruptedException e) {
				e.printStackTrace();
				return null;
			}
		}

	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Musimy również zawęzić łapane wyjątki w ramach metody
						fetch.</small>
				</section>

				<section data-auto-animate>
					<h4 data-id="code-title">Krok 4. Pierwsze zapytanie</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="25-26">
<script type="text/template">
	package org.example;

	import java.io.IOException;
	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	
	public class RickAndMortyFetcher {
		private static final HttpClient httpClient = HttpClient.newHttpClient();

		public static void main(String[] args) {
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=pickle";
			RickAndMortyFetcher fetcher = new RickAndMortyFetcher();
			System.out.println(fetcher.fetch(apiUrl));
		}
	
		public String fetch(String path) {
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(path))
					.GET()
					.build();
	
			try {
				HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
				return response.body();
			} catch (IOException | InterruptedException e) {
				e.printStackTrace();
				return null;
			}
		}

	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Skrócić można również ciało <em><b>try</b></em> w metodzie
						<em><b>fetch</b></em>.</small>
				</section>

				<section data-auto-animate>
					<h4 data-id="code-title">Krok 5. Data transfer object</h4>
					<small data-id="code-title-2"><em><b>org/example/CharacterResponseDTO.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers>
<script type="text/template">
package org.example;

import java.util.List;
import java.util.Objects;

public final class CharacterResponseDTO {
	private final InfoDTO info;
	private final List<CharacterDTO> results;

	public CharacterResponseDTO(
			InfoDTO info,
			List<CharacterDTO> results) {
		this.info = info;
		this.results = results;
	}

	public InfoDTO info() {
		return info;
	}

	public List<CharacterDTO> results() {
		return results;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) {
			return false;
		}
		var that = (CharacterResponseDTO) obj;
		return Objects.equals(this.info, that.info) &&
				Objects.equals(this.results, that.results);
	}

	@Override
	public int hashCode() {
		return Objects.hash(info, results);
	}

	@Override
	public String toString() {
		return "CharacterResponseDTO[" +
				"info=" + info + ", " +
				"results=" + results + ']';
	}

}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Tak wygląda, jedna z klas która posłuży do przemapowania odpowiedzi
						z serwa. Jej pola są takie same jak te w JSONie.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 5. Data transfer object</h4>
					<small data-id="code-title-2"><em><b>org/example/CharacterResponseDTO.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers>
<script type="text/template">
package org.example;

import java.util.List;

public record CharacterResponseDTO(
		InfoDTO info,
		List<CharacterDTO> results) {
}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Zapis ten można skrócić korzystając z <a
							href="https://javastart.pl/baza-wiedzy/slownik/rekordy">rekordów (Records)</a>. Ten zapis
						realizuje dokładnie to samo co widok wcześniej.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 5. Data transfer object</h4>
					<small data-id="code-title-2"><em><b>org/example/CharacterDTO.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="1-19|7">
<script type="text/template">
package org.example;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.List;

@JsonIgnoreProperties(ignoreUnknown = true)
public record CharacterDTO(
		Integer id,
		String name,
		String species,
		String type,
		String gender,
		List<String> episode,
		String url
) {
}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Klasa wykorzystywana we wcześniejszej
						<em><b>CharacterResponseDTO</b></em>. Nie są tutaj obecne wszystkie pola zwracane w odpowiedzi.
						Ponieważ będziemy korzystali z mappera z biblioteki Jackson, musimy zaznaczyć jak reagować w
						przypadku gdy wartość z JSONa, nie zostanie znaleziona. Dokonujemy tego za pomocą adnotacji
						<em><b> @JsonIgnoreProperties(ignoreUnknown = true)</b></em>.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 5. Data transfer object</h4>
					<small data-id="code-title-2"><em><b>org/example/InfoDTO.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers>
<script type="text/template">
	package org.example;

	public record InfoDTO(
			Integer count,
			Integer pages,
			String next,
			String prev
	) {
	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Kolejna klasa wykorzystywana we wcześniejszej
						<em><b>CharacterResponseDTO</b></em>. Służy ona do paginacji wyników, której świadomie nie
						obsłużymy w ramach zadania.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 6. Użycie mappera</h4>
					<small data-id="code-title-2"><em><b>build.gradle.kts</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code data-trim data-line-numbers="13">
<script type="text/template">
	plugins {
		id("java")
	}
	
	group = "org.example"
	version = "1.0-SNAPSHOT"
	
	repositories {
		mavenCentral()
	}
	
	dependencies {
		implementation("com.fasterxml.jackson.core:jackson-databind:2.12.7.1")
		testImplementation(platform("org.junit:junit-bom:5.9.1"))
		testImplementation("org.junit.jupiter:junit-jupiter")
	}
	
	tasks.test {
		useJUnitPlatform()
	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Aby skorzystać z biblioteki Jackson, należy dodać odpowiednią
						zależność. Po dodaniu nowej zależności w InteliliJ wyświetli się ikonka Słonika, należy ja
						kliknąć, aby IDE załadowało nowe bilbioteki.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 6. Użycie mappera</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
								<code class="hljs java" data-trim data-line-numbers="14">
								<script type="text/template">
									package org.example;
								
									import com.fasterxml.jackson.databind.ObjectMapper;
									import java.io.IOException;
									import java.net.URI;
									import java.net.http.HttpClient;
									import java.net.http.HttpRequest;
									import java.net.http.HttpResponse;
									import java.util.Collections;
									import java.util.List;
									
									public class RickAndMortyFetcher {
										private static final HttpClient HTTP_CLIENT = HttpClient.newHttpClient();
										private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
									
										public static void main(String[] args) {
											RickAndMortyFetcher fetcher = new RickAndMortyFetcher();
											System.out.println(fetcher.fetchCharacterByName("pickle"));
										}
									
										public List<CharacterDTO> fetchCharacterByName(String name) {
											String apiUrl = "https://rickandmortyapi.com/api/character/?name=" + name;
											String responseBody = fetch(apiUrl);
											try {
												CharacterResponseDTO responseDTO = OBJECT_MAPPER.readValue(responseBody, CharacterResponseDTO.class);
												return responseDTO.results();
											} catch (IOException e) {
												e.printStackTrace();
												return Collections.emptyList();
											}
										}
									
										private String fetch(String path) {
											HttpRequest request = HttpRequest.newBuilder()
													.uri(URI.create(path))
													.GET()
													.build();
											try {
												HttpResponse<String> response = HTTP_CLIENT.send(request, HttpResponse.BodyHandlers.ofString());
												return response.body();
											} catch (IOException | InterruptedException e) {
												e.printStackTrace();
												return null;
											}
										}
									
									}
								</script>
								</code>
								</pre>
					<small data-id="code-descrpiton">Wracamy do klasy <em><b>RickAndMortyFetcher</b></em>, w której
						skorzystamy z mappera z biblioteki Jackson. Tworzenie <em><b>ObjectMapper</b></em> jest również
						kosztowną operacją, dlatego tworzymy go jako <em><b>private static final</b></em>.
					</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 6. Użycie mappera</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="21,33|21-31">
<script type="text/template">
	package org.example;

	import com.fasterxml.jackson.databind.ObjectMapper;
	import java.io.IOException;
	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	import java.util.Collections;
	import java.util.List;
	
	public class RickAndMortyFetcher {
		private static final HttpClient HTTP_CLIENT = HttpClient.newHttpClient();
		private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
	
		public static void main(String[] args) {
			RickAndMortyFetcher fetcher = new RickAndMortyFetcher();
			System.out.println(fetcher.fetchCharacterByName("pickle"));
		}
	
		public List<CharacterDTO> fetchCharacterByName(String name) {
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=" + name;
			String responseBody = fetch(apiUrl);
			try {
				CharacterResponseDTO responseDTO = OBJECT_MAPPER.readValue(responseBody, CharacterResponseDTO.class);
				return responseDTO.results();
			} catch (IOException e) {
				e.printStackTrace();
				return Collections.emptyList();
			}
		}
	
		private String fetch(String path) {
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(path))
					.GET()
					.build();
			try {
				HttpResponse<String> response = HTTP_CLIENT.send(request, HttpResponse.BodyHandlers.ofString());
				return response.body();
			} catch (IOException | InterruptedException e) {
				e.printStackTrace();
				return null;
			}
		}
	
	}
</script>
</code>
</pre>
					<small>
						Tworzymy nowa metodę <em><b>fetchCharacterByName</b></em> i ograniczamy dostęp starej metody
						<em><b>fetch</b></em>. Metoda <em><b>readValue</b></em> z klasy <em><b>ObjectMapper</b></em>
						mapuje
						wartośc String
						zapisaną w formacie JSON, na listę utoworzoną przez nas klasę <em><b>CharacterDTO</b></em>
					</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 6. Użycie mappera</h4>
					<small data-id="code-title-2"><em><b>org/example/RickAndMortyFetcher.java</b></em></small>
					<pre style="font-size: 14px" data-id="code-animation">
<code class="hljs java" data-trim data-line-numbers="16-23">
<script type="text/template">
	package org.example;

	import com.fasterxml.jackson.databind.ObjectMapper;
	import java.io.IOException;
	import java.net.URI;
	import java.net.http.HttpClient;
	import java.net.http.HttpRequest;
	import java.net.http.HttpResponse;
	import java.util.Collections;
	import java.util.List;
	
	public class RickAndMortyFetcher {
		private static final HttpClient HTTP_CLIENT = HttpClient.newHttpClient();
		private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
	
		public static void main(String[] args) {
			RickAndMortyFetcher fetcher = new RickAndMortyFetcher();
			fetcher.fetchCharacterByName("Summer")
					.stream()
					.map(CharacterDTO::name)
					.distinct()
					.forEach(System.out::println);
		}
	
		public List<CharacterDTO> fetchCharacterByName(String name) {
			String apiUrl = "https://rickandmortyapi.com/api/character/?name=" + name;
			String responseBody = fetch(apiUrl);
			try {
				CharacterResponseDTO responseDTO = OBJECT_MAPPER.readValue(responseBody, CharacterResponseDTO.class);
				return responseDTO.results();
			} catch (IOException e) {
				e.printStackTrace();
				return Collections.emptyList();
			}
		}
	
		private String fetch(String path) {
			HttpRequest request = HttpRequest.newBuilder()
					.uri(URI.create(path))
					.GET()
					.build();
			try {
				HttpResponse<String> response = HTTP_CLIENT.send(request, HttpResponse.BodyHandlers.ofString());
				return response.body();
			} catch (IOException | InterruptedException e) {
				e.printStackTrace();
				return null;
			}
		}
	
	}
</script>
</code>
</pre>
					<small data-id="code-descrpiton">Wypiszmy, wszystkie wersje <em><b>Summer</b></em> występujące w
						serialu w czytelnym
						dla człowieka formacie.</small>
				</section>
				<section data-auto-animate>
					<h4 data-id="code-title">Krok 7... i dalej</h4>
					<p>Kolejne kroki nie zostały już opisane w ramach tej prezentacji. Dokończenie realizacji
						zadania pozostawione jest, jako ćwiczenie doskonalające.
					</p>
					<p>Ukończone całe zadanie jest dostępne <a
							href="https://github.com/Kajkitsu/rick_and_morty_fetcher">tutaj</a>.</p>
					<p>Stan programu na koniec kroku 6tego jest dostępny <a
							href="https://github.com/Kajkitsu/rick_and_morty_fetcher/tree/step_6">na
							tej gałęzi</a>. </p>
				</section>
			</section>

		</div>

	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>

		// Also available as an ES module, see:
		// https://revealjs.com/initialization/
		Reveal.initialize({
			controls: true,
			progress: true,
			center: true,
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
		});

	</script>

</body>

</html>