<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Języki i Techniki Programowania</title>

	<meta name="description" content="JTP LAB">
	<meta name="author" content="Norbert Waszkowiak">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section data-background-gradient="linear-gradient(45deg, #333, #1f7520)">
				<h2>Języki i Techniki Programowania</h2>
				<br slyle="height: 600px;" />
				<p style="text-align: left;">ppor. mgr inż. Norbert Waszkowiak</p>
				<div class="fragment" style="text-align: left;">
					<small>nr tel.: 261 839 060</small>
					<br />
					<small>e-mail: norbert.waszkowiak@wat.edu.pl</small>
					<br />
					<small>pomieszczenie: bud. 100 pok. 254B</small>
					<br />
					<small>konsultacje online i stacjanarnie: po wcześniejszym umówieniu</small>
				</div>
			</section>
			<section data-background-gradient="linear-gradient(to bottom, #000, #9c0101)">
				<h2>Zasady oceniania</h2>
				<section>
					<small>
						<ol>
							<li>Ostateczna ocena z laboratoriów będzie wynikiem egzaminu z cześci laboratoryjnej.
								Za aktywność na laboratoriach i realizacje zadań student może otrzymać maksymalnie 20
								punktów, które są wliczone do
								puli punktów z egzaminu.
							</li>
							<li>Obecność na wszystkich zajęciach jest obowiązkowa. Zaległości można usunąć uczestnicząc
								w
								zajęciach z inną grupą po wcześniejszym poinformowaniu prowadzącego. W przypadku, gdy
								zajęcia z pozostałymi grupami już się odbyły, można odrobić zajęcia na konsultacjach.
								Dopuszczalna liczba nieobecności: 1.</li>
							<li>Rozwiązania zadań z zajęć należy umiescić na platoformie MS Teams. Czas na wykonanie
								zadania
								to tydzień liczony od 23:59 dnia, w którym zostały zrealizowane zajęcia. Jeżeli
								termin
								oddania zadania przypadnie po rozpoczęciu sesji
								egzaminacyjnej, wtedy za termin oddania zadania przyjmuje się 24h przed rozpoczęciem
								sesji
								egzaminacyjnej.</li>
						</ol>
					</small>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(45deg, #c03090, #10a080)">
				<section>
					<h2>Lab 1-2</h2>
					<h3>Stos</h3>
				</section>
				<section>
					<h3>IDE</h3>
					<img src="assets/IntelliJ_IDEA_Icon.svg" style="height: 300px;" />
					<br />

					<a href="https://www.jetbrains.com/help/idea/installation-guide.html#silent">
						Instrukcja instalacji IntelliJ IDEA
					</a>
				</section>

				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1 cz.1 👨‍💻</h3>
					<small style="text-align: left; margin-left: 20px;">
						Wykonanie programu wymaga użycia stosu, na którym zapisywane są zmienne oraz ich wartości, tj.
						wartości prymitywne i odnośniki do obiektów - same obiekty są na tzw. składzie. W tym zadaniu
						zapisujemy stany stosu jako ciąg list par odpowiadający metodom na stosie i zmiennym
						zadeklarowanym
						i modyfikowanym w czasie ich wykonania. Lista par odpowiada metodzie na stosie, jest zapisana w
						nawiasie kwadratowym, a każda para składa się z nazwy zmiennej oraz jej wartości.
						<br />
						Np. <em>[…, (x, 7),(y, true)]main</em> to stan, w którym podczas wykonania metody <em>main</em>
						wartości zmiennych <em>x</em> i <em>y</em> są
						odpowiednio równe 7 i true.
						<br />
						Przeanalizuj następującą klasę i podaj stany stosu po wykonaniu linii 3,
						4, 5, 6, 7, 8 i 10.
					</small>

					<pre style="font-size: 14px" data-id="code-animation">
						<code class="hljs java" data-trim data-line-numbers><script type="text/template">
							public class State {
								public static void main(String[] args) {
									int m = 2;
									double d = 2.0;
									d = m * d;
									int n = 15 + (int) d; {
										int k = 8;
										d = d + k;
									}
									d = n / 4;
									System.out.println(d);
								}
							}
						</script>
						</code>
					</pre>
				</section>

				<section>
					<h3>Debugger</h3>
					<small style="text-align: left; margin: 20px;">(zwany również odpluskwiaczem) - narzędzie
						wbudowane w IDE umożliwiające śledzenie stosu i
						sterty (składu) w wybranych liniach kodu poprzez zatrzymywanie działania programu w danej
						linii.</small>
					<small style="text-align: left; margin: 20px;" class="fragment">Program działający w trybie
						debuggowania będzie wykonywał kolejne linijki kodu do momentu, w
						którym nie trafi na „<b>breakpoint</b>”, czyli linię kodu zaznaczoną przez programistę. Po
						zatrzymaniu
						się programu w wybranej linii, IDE wyświetli aktualny stos zawierający zmienne aplikacji.
						Użytkownik może zwolnić breakpoint, po czym program będzie wykonywany do napotkania kolejnego
						breakpoint'a. </small>
					<small style="text-align: left; margin: 20px;" class="fragment">W środowisku <b>Intellij
							IDEA</b>, aby wybrać linijkę kodu, w których program ma się zatrzymać
						(breakpoint), należy kliknąć po prawej stronie od numeru linii. Linia zapali się na czerwono
						oraz
						pojawi się czerwony okrąg.</small>
				</section>
				<section>
					<h3>Debugger</h3>
					<img src="assets/debugger1.png">
				</section>
				<section>
					<h3>Debugger</h3>
					<img src="assets/debugger2.png">
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1 cz.2 👨‍💻</h3>
					<small style="text-align: left; margin-left: 20px;">
						Podaj stany stosu wywołań i składu, gdy zostaną osiągnięte miejsca (1), (2) oraz (a) i (b).
						<br />
						Użyj debuggera(odpluskwiacza) do sprawdzenia otrzymanych wyników.
						<br />
						Uwaga: proszę pamiętać o parametrze <em>args</em> metody <em>main</em>.
						<br />
						Stos trzeba odpowiednio rozrysować, żeby było widać piętra odpowiadające metodom.
					</small>

					<pre style="font-size: 14px" data-id="code-animation">
						<code class="hljs java" data-trim data-line-numbers><script type="text/template">
							public class ValuePassing {
								public static int changei(int i) {
									int[] a = {i}; /* (a) */
									++i; /* (b) */
									return (i + a[0]);
								}
							
								public static void main(String[] args) {
									int i = 2; /* (1) */
									System.out.println("Przed wykonaniem i ma wartość" + i);
									int return_i = 0;
									return_i = changei(i); /* (2) */
									System.out.println("Changei daje w wyniku " + return_i);
									System.out.println("Wartosc i po wynosi " + i);
								}
							}
						</script>
						</code>
					</pre>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2 👨‍💻</h3>
					<small style="text-align: left; margin-left: 20px;">
						Zaimplementuj klasy <em>Point</em> i <em>Line</em> odpowiadające odpowiednio punktom i liniom w
						przestrzeni
						dwuwymiarowej z odpowiednimi konstruktorami. Klasy te mają zawierać metodę <em>move</em>
						pozwalającą na
						przesuwanie punktów i linii o wektor oraz metodę <em>flip</em> pozwalającą na przerzucanie
						symetryczne
						względem początku układu współrzędnych. Należy napisać testy metod i konstruktorów. Ile
						parametrów powinna mieć metoda <em>move</em>?
						<br />

						Wskazówka: w celu testowania należy zaimplementować odpowiednio metodę <em>toString()</em>
						zwracającą dla
						danego obiektu reprezentujący go string.</small>
				</section>
				<section>
					<h3>Testy jednostkowe</h3>
					<small style="text-align: left; margin: 20px;">
						Na potrzeby przeprowadzania testów jednostkowych w języku Java przygotowano narzędzia
						umożliwiające szybkie i sprawne pisanie testów jednostkowych nazwane Junit. Jest to biblioteka,
						która przy wykorzystaniu <b>anotacji</b> umożliwia definiowanie testów oraz przygotowanie
						obiektów do
						ich wykonania.
					</small>
					<small class="fragment" style="text-align: left; margin: 20px;">
						<b>Anotacja</b> - to część gramatyki języka, reprezentującąca konkretną logikę, którą w czasie
						budowania
						projektu wykonuje kompilator. Anotacje w Javie wstawia się zazwyczaj przed deklaracją
						klas, metod i atrybutów. W przykładzie widocznym po prawej stronie wykorzystywana jest anotacja
						<em>@Before</em> oraz <em>@Test</em>. Metoda poprzedzona anotacją <em>@Before</em> w klasie, w
						której się znajduje, zostanie wykonana przed wywołaniem testów. Anotacja <em>@Test</em>
						poprzedzająca metodę reprezentuje pojedynczy test jednostkowy.
					</small>
					<small class="fragment" style="text-align: left; margin: 20px;">
						Wynik testu będzie pozytywny, jeśli dla wyniku statycznej metody <em>assertEquals</em> wartości
						obu
						parametrów będą równe. W klasie <em>Assert</em> istnieją również inne metody umożliwiające
						przeprowadzanie testów, np. <em>assertTrue</em>, <em>assertNotNull</em> itp..
					</small>
					<small class="fragment" style="text-align: left; margin: 20px;">
						<b>Intellij IDEA</b> umożliwia wywoływanie pojedynczych testów lub wszystkich testów w klasie
						poprzez
						wciśnięcie odpowiednio zielonego przycisku przy numerze linii przy deklaracjach metod i przy
						deklaracji klasy.
					</small>
				</section>
				<section>
					<h3>JUnit</h3>
					<pre style="font-size: 16px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers="1-26|8|10-13|15-19|21-25">
						import static org.junit.Assert.assertEquals;

						import org.junit.Before;
						import org.junit.Test;
						
						public class CalculatorTest {
						
							private Calculator calculator;
						
							@Before
							public void init() {
								calculator = new Calculator();
							}
						
							@Test
							public void testIfAddProperly() {
								int result = calculator.add(4, 6);
								assertEquals(10, result);
							}
						
							@Test
							public void testIfMultiplyProperly() {
								int result = calculator.multiply(5, 5);
								assertEquals(25, result);
							}
						}
						
					</code></pre>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(20deg, #650000, #29448b)" data-auto-animate
				data-auto-animate-easing="cubic-bezier(0.770, 0.100, 0.175, 0.900)">
				<section>
					<h2>Lab 3-4</h2>
					<h3>Kolekcje</h3>
				</section>
				<section data-auto-animate data-auto-animate-easing="cubic-bezier(0.770, 0.100, 0.175, 0.900)">
					<div class="r-hstack justify-center">
						<div class="r-vstack" style="background: rgba(0, 0, 0, 0.336);">
							<div data-id="iterable" data-auto-animate-delay="0" class="fragment"
								style="background: rgb(80, 17, 54); ; width: 250px; height: 100px; margin: 10px;">
								<p style="font-size: 30px;" class="justify-center">java.lang.Iterable</p>
							</div>
							<div data-id="collection" data-auto-animate-delay="0" class="fragment"
								style="background: rgb(68, 31, 117); width: 300px; height: 100px; margin: 10px;">
								<p style="font-size: 30px;" class="justify-center">java.util.Collection</p>
							</div>
							<div class="r-hstack">
								<div data-id="list" data-auto-animate-delay="0" class="fragment"
									style="background: rgb(59, 57, 175); width: 160px; height: 100px; margin: 10px;">
									<p style="font-size: 25px;" class="justify-center">java.util.List</p>
								</div>
								<div data-id="set" data-auto-animate-delay="0.1" class="fragment"
									style="background: rgb(59, 57, 175); width: 160px; height: 100px; margin: 10px;">
									<p style="font-size: 25px;" class="justify-center">java.util.Set</p>
								</div>
								<div data-id="queue" data-auto-animate-delay="0.2" class="fragment"
									style="background: rgb(59, 57, 175); width: 160px; height: 100px; margin: 10px;">
									<p style="font-size: 25px;" class="justify-center">java.util.Queue</p>
								</div>
							</div>
						</div>
						<div data-id="map" data-auto-animate-delay="0.2" class="fragment"
							style="background: rgb(59, 57, 175); width: 160px; height: 100px; margin: 10px; margin-top: 250px;">
							<p style="font-size: 25px;" class="justify-center">java.util.Map</p>
						</div>
					</div>
				</section>
				<section>
					<h3>Typ generyczny</h3>
					<small style="margin-bottom: 10px;">Typ generyczny w Javie umożliwia tworzenie klas, interfejsów i
						metod, które są parametryzowane typem. Oznacza to, że możemy utworzyć klasę lub metodę, która
						będzie działać na różnych typach, a typ będzie określony w momencie tworzenia obiektu klasy lub
						wywoływania metody.</small>
					<small style="margin-bottom: 10px;">Typ generyczny definiuje się za pomocą parametru typu, który
						jest umieszczany w nawiasach trójkątnych &lt&gt. Parametr typu może być dowolnym typem, w tym
						klasą, interfejsem. Parametry typu pozwalają na tworzenie kodu, który jest bardziej ogólny i
						elastyczny, ponieważ typy argumentów mogą być różne dla różnych wywołań klasy lub
						metody.</small>
					<small style="margin-bottom: 10px;">Użycie typów generycznych pozwala na uniknięcie rzutowania typów
						i poprawia bezpieczeństwo typów, ponieważ typy argumentów są sprawdzane w czasie kompilacji. Typ
						generyczny może być używany nie tylko w klasach, ale także w interfejsach i metodach.</small>
					<small style="margin-bottom: 10px;">Przykładem klasy generycznej w Javie jest ArrayList&ltT&gt,
						gdzie T oznacza typ elementów przechowywanych w liście. W momencie tworzenia obiektu ArrayList
						możemy określić typ elementów, na przykład ArrayList&ltString&gt lub
						ArrayList&ltInteger&gt.</small>
				</section>
				<section>
					<h3>Typ generyczny</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
						public class Box<T> {
							private T content;
						
							public Box(T content) {
								this.content = content;
							}
						
							public T getContent() {
								return content;
							}
						
							public void setContent(T content) {
								this.content = content;
							}
						}
						</script></code></pre>

					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
							Box<Integer> intBox = new Box<>(42);
							int intValue = intBox.getContent();
							
							Box<String> stringBox = new Box<>("Hello");
							String stringValue = stringBox.getContent();
						</script></code></pre>

				</section>
				<section>
					<h3>Collection&ltE&gt</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
// dodaje nowy element do kolekcji
boolean add(E element) 

// dodaje do kolekcji wszystkie elementy z innej kolekcji
boolean addAll(Collection<? extends E> c) 

// usuwa wszystkie elementy z kolekcji
void clear() 

// sprawdza, czy kolekcja zawiera podany element
boolean contains(Object o) 

// sprawdza, czy kolekcja zawiera wszystkie elementy z innej kolekcji
boolean containsAll(Collection<?> c) 

// sprawdza, czy kolekcja jest pusta
boolean isEmpty() 

// zwraca iterator umożliwiający iterowanie po elementach kolekcji
Iterator<E> iterator() 

// usuwa podany element z kolekcji
boolean remove(Object o) 

// usuwa z kolekcji wszystkie elementy, które znajdują się w innej kolekcji
boolean removeAll(Collection<?> c) 

// pozostawia w kolekcji tylko te elementy, które znajdują się w innej kolekcji
boolean retainAll(Collection<?> c) 

// zwraca liczbę elementów w kolekcji
int size() 
					</script></code></pre>
				</section>
				<section>
					<h3>List&ltE&gt</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
// dodaje nowy element na wskazanej pozycji
void add(int index, E element)

// zwraca element o wskazanym indeksie
E get(int index)

// ustawia nową wartość dla elementu o wskazanym indeksie
E set(int index, E element)

// usuwa element o wskazanym indeksie z listy
E remove(int index)

// zwraca indeks pierwszego wystąpienia danego obiektu na liście
int indexOf(Object o)

// zwraca indeks ostatniego wystąpienia danego obiektu na liście
int lastIndexOf(Object o)

// zwraca widok listy zawierający elementy od podanego indeksu do
// końcowego indeksu (bez niego)
List<E> subList(int fromIndex, int toIndex)
</script></code></pre>
				</section>
				<section>
					<h3>ArrayList&ltE&gt</h3>
					<small>
						<ul>
							<li>Jest to tablica dynamiczna, która może zwiększać swój rozmiar wraz ze wzrostem ilości
								elementów.
							</li>
							<li>
								W ArrayListach dostęp do elementów jest szybszy niż w LinkedListach, ponieważ elementy
								są przechowywane w pamięci w
								sposób ciągły, co pozwala na prostsze operacje odczytu i zapisu.
							</li>
							<li>
								W ArrayListach usuwanie elementów z początku lub środka listy może być kosztowne
								czasowo, ponieważ wymaga przesunięcia
								wszystkich elementów za usuwanym.
							</li>
							<li>
								Dostęp do elementów w ArrayListach jest O(1), a wyszukiwanie O(n).</li>
						</ul>
					</small>
				</section>
				<section>
					<h3>LinkedList&ltE&gt</h3>
					<small>
						<ul>
							<li>Jest to lista dwukierunkowa, w której każdy element przechowuje referencję do swojego
								poprzednika i następnika.</li>
							<li>W LinkedListach dodawanie i usuwanie elementów z początku i środka listy jest szybsze
								niż w ArrayListach, ponieważ nie
								wymaga przesuwania innych elementów.</li>
							<li>W LinkedListach dostęp do elementów jest wolniejszy niż w ArrayListach, ponieważ
								elementy nie są przechowywane w pamięci
								w sposób ciągły, co wymaga dodatkowych operacji przeglądania listy w celu znalezienia
								danego elementu.</li>
							<li>Dostęp do elementów w LinkedListach jest O(n), a wyszukiwanie O(n).</li>
						</ul>
					</small>
				</section>

				<section>
					<h3>Set&ltE&gt</h3>
					<small>Interfejs Set w języku Java reprezentuje kolekcję unikalnych elementów, bez określonej
						kolejności. Oznacza to, że
						elementy w Set nie mogą się powtarzać.</small>
					<small>Interfejs Set&ltE&gt oprócz metod pochodzących z interfejsu Collection&ltE&gt posiada
						wyłącznie metody wytwórze, np.:
					</small>
					<pre style="font-size: 18px" data-id="code-animation">
	<code class="hljs java" data-trim data-line-numbers>
		<script type="text/template">
static <E> Set<E> of(E e1) 
static <E> Set<E> of(E e1, E e2)
static <E> Set<E> of(E... elements) 
</script></code></pre>
				</section>
				<section>
					<h3>HashSet&ltE&gt</h3>
					<p>
						reprezentuje zbiór nieuporządkowany, w którym elementy są przechowywane w tablicy
						skrótów (hash table). Zbiór
						ten nie gwarantuje, że elementy będą przechowywane w jakiejkolwiek określonej kolejności, ale
						zapewnia, że każdy element
						jest unikalny i posiada wyznaczalny hash code.
					</p>
				</section>
				<section>
					<h3>TreeSet&ltE&gt</h3>
					<p>
						reprezentuje zbiór uporządkowany, w którym elementy są przechowywane w drzewie
						czerwono-czarnym. Zbiór ten
						zapewnia, że elementy są przechowywane w porządku naturalnym (według relacji "mniejszy/równy"),
						a każdy element jest
						unikalny. TreeSet oferuje także dodatkowe metody, umożliwiające dostęp do pierwszego i
						ostatniego elementu w zbiorze, a
						także do elementów znajdujących się przed lub po danym elemencie.
					</p>
				</section>
				<section>
					<h3>LinkedHashSet&ltE&gt</h3>
					<p>
						reprezentuje zbiór uporządkowany, w którym elementy są przechowywane w
						kolejności dodania. Zbiór ten
						łączy funkcjonalności HashSet i List, oferując unikalność elementów oraz zachowanie kolejności
						dodania.
					</p>
				</section>
				<section>

					<h3>Queue&ltE&gt</h3>
					<small>
						<a href="https://youtu.be/0V9Ua538jMI?t=223">Jak to wymawiać?</a>
					</small>
					<p>
						Interfejs Queue w języku Java reprezentuje kolejkę, czyli strukturę danych, w której elementy są
						przechowywane w
						kolejności, w jakiej zostały dodane, a pobierane są w kolejności, w jakiej zostały dodane.
						Kolejka jest strukturą typu
						FIFO (First In, First Out), co oznacza, że element, który pierwszy został dodany do kolejki,
						jest też jako pierwszy
						pobierany z kolejki.
					</p>
				</section>
				<section>
					<h3>
						Queue&ltE&gt
					</h3>
					<pre style="font-size: 18px" data-id="code-animation">
					<code class="hljs java" data-trim data-line-numbers><script type="text/template">
// dodaje element do kolejki. Zwraca true, jeśli element został pomyślnie dodany, a false, jeśli dodanie elementu jest niemożliwe (np. w przypadku pełnej kolejki).
boolean add(E element)

// dodaje element do kolejki. Zwraca true, jeśli element został pomyślnie dodany, a false, jeśli dodanie elementu jest niemożliwe (np. w przypadku pełnej kolejki).
boolean offer(E element)

// pobiera i usuwa element znajdujący się na początku kolejki. Rzuca wyjątek NoSuchElementException, jeśli kolejka jest pusta.
E remove()

// pobiera i usuwa element znajdujący się na początku kolejki. Zwraca null, jeśli kolejka jest pusta.
E poll()

// pobiera, ale nie usuwa element znajdujący się na początku kolejki. Rzuca wyjątek NoSuchElementException, jeśli kolejka jest pusta.
E element()

// pobiera, ale nie usuwa element znajdujący się na początku kolejki. Zwraca null, jeśli kolejka jest pusta.
E peek()
						</script></code></pre>
				</section>
				<section>
					<h3>
						Deueue&ltE&gt
					</h3>
					<small>
						to skrót od "Double Ended Queue", czyli kolejkę dwukierunkową. Deque rozszerza interfejs Queue,
						a więc dziedziczy po nim
						wszystkie jego metody. Dodatkowo, Deque oferuje także metody umożliwiające dodawanie i usuwanie
						elementów zarówno z
						początku, jak i z końca kolejki. Dzięki temu, w przeciwieństwie do zwykłej kolejki, Deque
						pozwala na dodawanie i
						usuwanie elementów z dowolnego końca struktury.
					</small>
				</section>
				<section>
					<h3>BlockingQueue&ltE&gt</h3>
					<small>
						to interfejs, który oferuje metody blokujące. Metody te umożliwiają wątkowi czekanie na elementy
						w kolejce, jeśli
						kolejka jest pusta, lub czekanie na wolne miejsce w kolejce, jeśli kolejka jest pełna.
						Najważniejsze metody to put(E e),
						które umożliwia dodanie elementu do kolejki, ale jeśli kolejka jest pełna, to metoda zawiesza
						wątek wywołujący put(E e)
						aż do momentu, gdy miejsce w kolejce się zwolni. Metoda take() pobiera element z kolejki, ale
						jeśli kolejka jest pusta,
						to metoda zawiesza wątek wywołujący take() aż do momentu, gdy element pojawi się w kolejce.
						Metody BlockingQueue są
						często wykorzystywane w aplikacjach wielowątkowych, w których wątki muszą synchronizować swoje
						działania.
					</small>

				</section>
				<section>
					<h3>TransferQueue&ltE&gt</h3>
					<small>
						to interfejs, który rozszerza interfejs BlockingQueue. TransferQueue oferuje dodatkowe metody
						umożliwiające bezpieczne
						przekazywanie elementów między wątkami.

						W BlockingQueue wątek, który chce dodać element do kolejki lub pobrać element z kolejki, może
						zostać zablokowany, jeśli
						kolejka jest pełna lub pusta, odpowiednio. Natomiast w TransferQueue dodanie elementu do kolejki
						może być zablokowane,
						jeśli nie ma wątku, który czeka na element, który ma być dodany, a pobranie elementu z kolejki
						może być zablokowane,
						jeśli nie ma elementu, który ma zostać pobrany.

						Metoda put() w BlockingQueue będzie blokować wątek, aż element zostanie dodany do kolejki,
						natomiast metoda transfer() w
						TransferQueue będzie blokować wątek, aż element zostanie pobrany z kolejki lub do kolejki
						zostanie dodany wątek, który
						będzie oczekiwał na element.
					</small>
				</section>
				<section>
					<h3>Map&ltK, V&gt</h3>
					<small>
						Interfejs Map w języku Java reprezentuje strukturę danych, która przechowuje pary klucz-wartość.
						Każdy klucz musi być
						unikalny w ramach mapy, a wartość może być dowolnym obiektem. Interfejs Map zawiera wiele metod,
						które umożliwiają
						manipulowanie danymi w mapie, takie jak:
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
																					// dodaje element o kluczu key i wartości value do mapy. Zwraca 
																					// poprzednią wartość przypisaną do klucza, lub null jeśli klucz 
																					// nie był wcześniej przypisany do żadnej wartości.
																					void put(K key, V value)
																					
																					// zwraca wartość przypisaną do klucza key, lub null jeśli klucz nie 
																					// istnieje w mapie.
																					V get(Object key)
																					
																					// usuwa element o kluczu key z mapy i zwraca wartość, która była związana 
																					// z tym kluczem, lub null jeśli klucz nie istnieje w mapie.
																					V remove(Object key)
																					
																					// zwraca true, jeśli mapa zawiera klucz key, lub false w przeciwnym 
																					// przypadku.
																					boolean containsKey(Object key)
																					
																					//  zwraca true, jeśli mapa zawiera wartość value, lub false w przeciwnym 
																					// przypadku.
																					boolean containsValue(Object value)

																					// zwraca liczbę elementów w mapie.
																					int size()

																					// zwraca true, jeśli mapa jest pusta, lub false w przeciwnym 
																					// przypadku.
																					boolean isEmpty()
																					
																					// zwraca zbiór kluczy zawartych w mapie.
																					Set<K> keySet()
																					
																					// zwraca kolekcję wartości zawartych w mapie.
																					Collection<V> values()
																					
																					// zwraca zbiór obiektów typu Map.Entry, reprezentujących pary 
																					// klucz-wartość znajdujące się w mapie.
																					Set<Map.Entry<K,V>> entrySet()
																					</script></code></pre>
				</section>
				<section>
					<h3>HashMap&ltE&gt, TreeMap&ltE&gt i LinkedHashMap&ltE&gt</h3>
					<small>
						<ul>
							<li>HashMap to implementacja Map, która nie gwarantuje zachowania kolejności elementów.
								Elementy
								są przechowywane w taki
								sposób, aby umożliwić szybki dostęp do nich za pomocą klucza. TreeMap natomiast
								przechowuje
								elementy w drzewie, które
								jest posortowane według klucza. LinkedHashMap zachowuje kolejność elementów taką, jaką
								miała
								podczas dodawania.</li>
							<li>HashMap ma złożoność czasową O(1) dla operacji dodawania, usuwania i wyszukiwania
								elementów,
								pod warunkiem, że funkcja
								mieszająca (ang. hash function) działa dobrze i klucze są dobrze rozłożone w tablicy
								mieszającej. TreeMap ma złożoność
								czasową O(log n) dla tych samych operacji, a LinkedHashMap ma nieco gorszą złożoność
								czasową
								O(1) dla dodawania,
								usuwania i wyszukiwania elementów w porównaniu do HashMap, ale lepszą niż TreeMap.</li>
							<li>
								W przypadku HashMap i LinkedHashMap, kolejność elementów nie jest gwarantowana i może
								ulec
								zmianie w czasie, natomiast
								TreeMap gwarantuje posortowanie elementów według klucza.
							</li>
							<li>
								LinkedHashMap pozwala na iterowanie po elementach w kolejności dodania, co może być
								przydatne w niektórych sytuacjach.
							</li>
						</ul>
					</small>
				</section>
				<section>
					<h3>Repozytorium z testami kolekcji</h3>
					<a href="https://github.com/Kajkitsu/Java_collection_tests">Link</a>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Rozważ użycie interfejsów Set, List, Queue i Map dla każdego z
						następujących przypadków (zobacz specyfikację Java API). Ustal, który z
						nich jest najbardziej odpowiedni oraz wyjaśnij, jak użyć go w
						implementacji.
						<ul>
							<li>Pewna firma chce odpowiednio zapisać swoich klientów. Każdego miesiąca będą
								oni losowo wybierani aby otrzymać mały upominek. Trzeba wybrać strukturę danych
								odpowiednią dla losowania.</li>
							<li>Ta sama firma chce ponazywać produkty imionami swoich pracowników. Każde
								imię będzie użyte tylko raz. Trzeba przygotować listę imion.</li>
							<li>W końcu firma ta zdecydowała się użyć tylko najczęściej występujących imion
								swoich pracowników do nazwania produktów. Policzono ilu pracowników posiada
								dane imię. Trzeba przygotować listę imion.</li>
							<li>
								Firma chce rozprowadzić bilety na mecze lokalnej drużyny siatkarskiej. Trzeba
								skonstruować odpowiednią listę oczekujących.
							</li>
						</ul>
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Napisz program, który będzie losował nazwiska klientów z listy (zobacz
						punkt 1. poprzedniego zadania), a następnie je usuwał. Dokładniej,
						zaimplementuj klasę Names z obiektowym
						atrybutem names odpowiadającym wspomnianej liście i z obiektową
						metodą choose(), która zwraca losowo wybrane nazwisko z
						listy names usuwając je jednocześnie.
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 3</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Napisz program, który będzie wybierał najczęściej występujące imiona
						klientów z listy (zobacz punkt 3. zadania 1.), a następnie je
						usuwał. Dokładniej, zaimplementuj klasę FrequentNames z obiektowym
						atrybutem frequentNames i z obiektową metodą choose(), która zwraca
						najczęściej występujące imię z listy frequentNames usuwając je
						jednocześnie, oraz metodę insert(String name) wstawiającą imię do
						danej listy
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 4</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj listy jednokierunkowe zawierające liczby całkowite
						(typ int) bez użycia kolekcji. Lista ma się składać z kotwicy, tj. obiektu
						klasy Anchor, oraz elementów, tj. obiektów klasy Element. Obiekty klasy
						Element mają posiadać atrybut val typu int oraz opcjonalnie wskaźnik na
						następny element listy, dokładniej obiekt klasy Element. Klasa Anchor ma
						posiadać atrybut first typu Element wskazujący na pierwszy element listy
						oraz metody:
						<ul>
							<li>insertAtTheFront(int x) - wstawiającą liczbę x na początek listy</li>
							<li>insertAtTheEnd(int x) - wstawiającą liczbę x na koniec listy</li>
							<li>removeFirst() - usuwającą pierwszy element listy</li>
							<li>removeLast() - usuwającą ostatni element listy</li>
							<li>toString() - zwracająca string reprezentujący daną listę</li>
							<li>equals(Object o) - sprawdzającą, czy dwie listy zawierają dokładnie te same liczby w
								tym samym porządku; jeśli tak, ma ona zwracać true, w przeciwnym wypadku false</li>
						</ul>
					</small>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(30deg, #29558b, #3dd48b)">
				<section>
					<h2>Lab 5-6</h2>
					<h3>Metody i atrybuty statyczne. Wyjątki</h3>
				</section>
				<section>
					<h3>Pola (atrybuty) statyczne</h3>
					<small>Pola statyczne są współdzielone przez wszystkie obiekty klasy i są inicjowane tylko raz, gdy
						klasa jest ładowana przez
						maszynę wirtualną. W przeciwieństwie do pól niestatycznych, pola statyczne mogą być odczytywane
						i modyfikowane bez
						tworzenia instancji klasy. Są one często używane do przechowywania danych, które są wspólne dla
						wszystkich obiektów
						klasy, np. stałych lub liczników.</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
public class Counter {
    private static int count = 0; // pole statyczne

    public Counter() {
        count++; // inkrementuj pole statyczne przy tworzeniu nowego obiektu
    }

    public static int getCount() { // metoda statyczna
        return count;
    }
}
</script></code></pre>
				</section>
				<section>
					<h3>Metody statyczne</h3>
					<small>
						Meotdy statyczne to takie, które działają na poziomie klasy, a nie na poziomie obiektów. Metody
						te są zwykle używane do wykonania
						operacji, które nie wymagają dostępu do pól niestatycznych i które nie są związane z określonymi
						instancjami klasy.
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
public class MathUtil {
    public static int factorial(int n) {
        int result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }
}
										</script></code></pre>
					<small>
						W tym przykładzie metoda <b><em>factorial()</em></b> oblicza silnię liczby całkowitej i jest
						zdefiniowana jako metoda statyczna. Możemy
						jej używać bez tworzenia instancji klasy, <br /> np. <b><em>int result =
								MathUtil.factorial(5);</em></b>
					</small>
				</section>
				<section>
					<h3>Wyjątki</h3>
					<small>Wyjątki w języku Java to mechanizm pozwalający na obsługę błędów i wyjątkowych sytuacji
						podczas wykonywania programu. W
						momencie wystąpienia błędu w czasie działania programu, maszyna wirtualna Javy generuje wyjątek
						(exception), który
						przerywa normalny przepływ wykonywania kodu i przechodzi do bloku kodu obsługi wyjątku.</small>
					<img src="assets/exceptions.png">

				</section>
				<section>
					<h3>Obsługa wyjątków</h3>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
try {
    // kod, który może rzucić wyjątek
} catch (ExceptionType e) {
    // kod obsługi wyjątku
} finally {
    // kod, który zostanie wykonany zawsze, 
		// niezależnie od wystąpienia wyjątku
}

																				</script></code></pre>
					<small>
						Blok <em><b>try</b></em> zawiera kod, który może rzucić wyjątek, a blok <em><b>catch</b></em>
						zawiera kod obsługi wyjątku, który zostanie wykonany tylko
						wtedy, gdy wyjątek zostanie rzucony. Blok <em><b>finally</b></em> zawiera kod, który zostanie
						wykonany zawsze, niezależnie od tego, czy
						wyjątek został rzucony czy nie.
					</small>
				</section>
				<section>
					<h3>Propagacja wyjątków</h3>
					<small>
						Gdy wyjątek jest zgłaszany przez metodę, to metoda może albo obsłużyć wyjątek (przy użyciu bloku
						<em><b>try-catch</b></em>), albo
						przekazać wyjątek wyżej w stosie wywołań do wywołującej metodę. Jeśli wyjątek nie jest obsłużony
						przez żadną metodę na
						stosie wywołań, to program kończy działanie, a wyjątek jest wyświetlany w konsoli.
					</small>
					<pre style="font-size: 18px" data-id="code-animation"><code class="hljs java" data-trim data-line-numbers><script type="text/template">
								try {
            try {
                System.out.println("Chyba wszystko OK"); //instrukcja się nie wykona
                throw new ParseException("Błąd parsowania", 1); // Tu mamy wyjątek (ParseException) - przerwanie bloku try
            } catch (ClassCastException e) { // Nie pasuje
                e.printStackTrace();
            } catch (NumberFormatException e) { // Nie pasuje - przerywa blok try!!!
                e.printStackTrace();
            }
        } catch (NullPointerException e) { // Nie pasuje
            e.printStackTrace();
        } catch (RuntimeException e) { // Nie pasuje
            e.printStackTrace();
        } catch (Exception e) { // Pasuje wykonanie bloku catch
            System.out.println("O! to sie wykona");
            e.printStackTrace();
        }
																																			</script></code></pre>
				</section>
				<section>
					<h3>Deklarowanie własnych wyjątków</h3>
					<small>TODO</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 1</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj klasę Factorial (silnia) z metodą factorial(int x) liczącą silnię x. Jaką
						sygnaturę powinna mieć ta
						metoda.
						<ol type="A">
							<li>Zachowując tę sygnaturę, zmodyfikuj tę implementację tak, aby dla x &lt 0 metoda nie
								zwracała wartości</li>
							<li>
								Zaimplementuj metodę factorial1, która dla liczb ujemnych będzie rzucać wyjątek
								MyException. MyException ma bezpośrednio
								rozszerzać Exception. Jak trzeba zmienić sygnaturę metody factorial?
							</li>
							<li>
								Jaka jest różnica pomiędzy tym a poprzednim rodzajem wyjątków?
							</li>
							<li>
								Przetestuj obie metody implementując metodę main tak, żeby w niej metody były sprawdzane
								dla ciągu argumentów typu: -3,
								-1, 0, 1, 2, 4, 5. Wskazówka: można użyć metody toString.
							<li>
								Użyj metody printStackTrace do pokazania zawartości stosu wywołań w momencie rzucania
								wyjątku.
							</li>
						</ol>
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 2</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj klasę DoTrzechRazySztuka, która sczytuje z konsoli liczbę <em>float</em> i
						wypisuje ją w postaci np. <em>„x = 1.2”</em>
						(zobacz slajdy z pierwszego wykładu). Metoda ta powinna dopuszczać maksymalnie dwa błędy w typie
						danych, np. jeśli
						podczas pierwszej próby wpisany będzie string <em>„abc”</em>, to jest to błąd i metoda powinna
						zażądać innej danej i tak
						maksymalnie dwa razy. Metoda ma kończyć swoje wykonanie po pierwszym wprowadzeniu <em>float</em>
						lub po trzech nieudanych
						próbach.
					</small>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie 3</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">
						Zaimplementuj klasy <em><b>Point</b></em>, <em><b>Line</b></em>, <em><b>Polygon</b></em>,
						<em><b>Group</b></em>. Przedostatnia klasa ma implementować wielokąty wyznaczone przez pewną
						liczbę punktów. Ostatnia klasa ma implementować grupy figur (jak w przypadku edytorów typu
						PowerPoint). Wszystkie klasy
						mają implementować interfejs <em><b>Figur</b></em> (lub klasę abstrakcyjną z abstrakcyjnymi
						metodami min. <em><b>equals(Object o)</b></em> żeby wymusić
						nadpisanie). Zaimplementuj również klasę <em><b>Group</b></em> grupująca figury i również
						implementującą <em><b>Figure</b></em>. <em><b>Figure</b></em> ma posiadać
						metody:
						<br/>
						<ol>
							<li><em><b>move(double dx, double dy)</b></em> przesuwającą daną figurę</li>
							<li><em><b>flip()</b></em> przerzucająca dana figurę</li>
							<li><em><b>equals(Object o)</b></em> sprawdzającą, czy figury są równe</li>
							<li><em><b>toString()</b></em> zwracająca łańcuch znaków (String) reprezentujący daną figurę
							</li>
						</ol>
					</small>
				</section>

			</section>
			<section data-background-gradient="linear-gradient(60deg, #ae9852, #a3548b)">
				<section>
					<h2>Lab 7-10</h2>
					<h3>TBA</h3>
				</section>
				<section data-transition="slide" data-background="#202020" data-background-transition="zoom">
					<h3>Zadanie</h3>
					<small style="text-align: left; margin-left: 30px;" style="text-align: left;">

					</small>
				</section>
			</section>

		</div>

	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>

		// Also available as an ES module, see:
		// https://revealjs.com/initialization/
		Reveal.initialize({
			controls: true,
			progress: true,
			center: true,
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
		});

	</script>

</body>

</html>